{"version":3,"sources":["../src/core/engine/useListEngine.ts","../src/core/store/listStore.ts","../src/core/registry/compiledFeaturePlan.ts","../src/core/context/createListRuntime.ts","../src/core/contracts/validateUiWiring.ts","../src/core/context/listContext.tsx","../src/ListDisplay.tsx","../src/core/store/featureState.ts","../src/features/actions/generalActionsFeature.ts","../src/features/actions/rowActionsFeature.ts","../src/features/filtering/filteringFeature.ts","../src/features/modals/modalsFeature.ts","../src/features/pagination/paginationFeature.ts","../src/features/selection/selectionFeature.ts","../src/features/sorting/sortingFeature.ts"],"names":["useEffect","jsx","FEATURE_ID","getModalsApi"],"mappings":"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","file":"index.js","sourcesContent":["import { useCallback, useEffect } from \"react\";\nimport {CoreListState} from \"../store/coreState\";\nimport {ListStore} from \"../store/listStore\";\n\n\n/**\n * Result object returned from data source initialization.\n *\n * @remarks\n * This type defines the structure of the result returned by the `init` method of a data source.\n * It provides the initial rows and optional status information about the initialization operation.\n * If rows are not provided, an empty array will be used. If status is not provided, \"ready\" will\n * be assumed as the default status.\n *\n * @typeParam TRow - The type of individual row data objects\n *\n * @internal\n */\nexport type DataSourceInitResult<TRow> = {\n    rows?: TRow[];\n    status?: \"ready\" | \"loading\" | \"error\";\n};\n\n/**\n * Interface defining the contract for data sources that provide rows to the list engine.\n *\n * @remarks\n * This type describes the required and optional methods that a data source must implement\n * to work with the list engine. Data sources are responsible for:\n * - Initial data loading via the `init` method\n * - Optional real-time updates via the `subscribe` method\n * - Optional cleanup operations via the `destroy` method\n *\n * The data source abstraction allows the list engine to work with various data providers\n * including static data, REST APIs, WebSocket connections, or any other data source that\n * implements this interface.\n *\n * @typeParam TRow - The type of individual row data objects provided by the data source\n * @typeParam TPatch - The type of patch objects used for incremental updates (defaults to unknown)\n *\n * @internal\n */\nexport type DataSource<TRow, TPatch = unknown> = {\n    /**\n     * Initializes the data source and retrieves the initial set of rows.\n     *\n     * @remarks\n     * This method is called once during the initial setup of the list engine. It should\n     * perform any necessary initialization operations and return the initial data set.\n     * The method is asynchronous to support data sources that require network requests\n     * or other async operations.\n     *\n     * @returns A promise that resolves to a DataSourceInitResult containing the initial rows and status\n     */\n    init: () => Promise<DataSourceInitResult<TRow>>;\n\n    /**\n     * Optional method to subscribe to incremental data updates.\n     *\n     * @remarks\n     * If provided, this method allows the data source to push incremental updates (patches)\n     * to the list engine after the initial load. The subscription mechanism enables real-time\n     * data synchronization without requiring full data reloads.\n     *\n     * @param onPatch - Callback function that receives patch objects when updates occur\n     * @returns Optional cleanup function to unsubscribe from updates\n     */\n    subscribe?: (onPatch: (patch: TPatch) => void) => void | (() => void);\n\n    /**\n     * Optional cleanup method called when the data source is no longer needed.\n     *\n     * @remarks\n     * This method should release any resources held by the data source, such as network\n     * connections, timers, or event listeners. It is called during component unmounting\n     * or when the data source is replaced.\n     */\n    destroy?: () => void;\n};\n\n/**\n * Function type for applying incremental patches to the current row data.\n *\n * @remarks\n * This function type defines the signature for patch application logic that transforms\n * the current rows based on a patch object. The patch application function is responsible\n * for interpreting the patch format and producing an updated rows array.\n *\n * Common patch operations include:\n * - Adding new rows to the array\n * - Updating existing rows based on identifiers\n * - Removing rows from the array\n * - Reordering rows\n *\n * The function must return a new array and should not mutate the input rows array to\n * maintain immutability and ensure proper change detection.\n *\n * @typeParam TRow - The type of individual row data objects\n * @typeParam TPatch - The type of patch objects that describe incremental changes\n *\n * @param rows - The current array of rows before the patch is applied\n * @param patch - The patch object describing the changes to apply\n * @returns A new array of rows with the patch applied\n *\n * @internal\n */\nexport type ApplyPatchFn<TRow, TPatch> = (rows: TRow[], patch: TPatch) => TRow[];\n\n/**\n * React hook that manages the list engine lifecycle, data loading, and real-time updates.\n *\n * @remarks\n * This hook coordinates the core list engine operations including:\n * - Initial data loading from the data source\n * - State management through the provided store\n * - Real-time data synchronization via subscription patches\n * - Manual refresh capabilities\n * - Cleanup on component unmount\n *\n * The hook integrates the data source with the list store, handling loading states,\n * error states, and data updates automatically. It sets up the subscription to patches\n * if the data source supports it and applies patches using the provided applyPatch function.\n *\n * Lifecycle behavior:\n * - On mount: Calls refresh() to perform initial data load\n * - On mount: Subscribes to data source patches if subscribe method is available\n * - On unmount: Unsubscribes from patches and calls destroy() on the data source\n * - On dependency change: Re-initializes the entire lifecycle\n *\n * @typeParam TRow - The type of individual row data objects\n * @typeParam TPatch - The type of patch objects used for incremental updates\n *\n * @param args - Configuration object for the list engine\n * @param args.store - The list store instance that manages the list state\n * @param args.dataSource - The data source that provides rows and optional real-time updates\n * @param args.applyPatch - Optional function to apply patches to the current rows array\n *\n * @returns Object containing the refresh function for manual data reloading\n *\n * @internal\n */\nexport function useListEngine<TRow, TPatch>(args: {\n    store: ListStore<CoreListState<TRow>>;\n    dataSource: DataSource<TRow, TPatch>;\n    applyPatch?: ApplyPatchFn<TRow, TPatch>;\n}) {\n    const { store, dataSource, applyPatch } = args;\n\n    const refresh = useCallback(async () => {\n        store.setState((prev) => ({ ...prev, status: \"loading\", error: undefined }));\n\n        try {\n            const result = await dataSource.init();\n            store.setState((prev) => ({\n                ...prev,\n                rawRows: result.rows ?? [],\n                status: (result.status as any) ?? \"ready\",\n                error: undefined,\n            }));\n        } catch (err) {\n            store.setState((prev) => ({ ...prev, status: \"error\", error: err }));\n        }\n    }, [dataSource, store]);\n\n    useEffect(() => {\n        refresh();\n\n        if (!dataSource.subscribe) return;\n\n        const unsub = dataSource.subscribe((patch) => {\n            if (!applyPatch) return;\n\n            store.setState((prev) => ({\n                ...prev,\n                rawRows: applyPatch(prev.rawRows, patch),\n            }));\n        });\n\n        return () => {\n            if (typeof unsub === \"function\") unsub();\n            dataSource.destroy?.();\n        };\n    }, [dataSource, applyPatch, refresh, store]);\n\n    return { refresh };\n}\n","/**\n * Function type for state change notification callbacks.\n *\n * @remarks\n * This function type represents a listener callback that is invoked whenever the state\n * in a {@link ListStore} changes. Listeners receive no parameters and return no value,\n * making them simple notification callbacks that trigger reactive updates in response\n * to state mutations.\n *\n * Listeners are registered via the {@link ListStore.subscribe} method and are called\n * synchronously after each state change. They are typically used to trigger re-renders\n * in UI frameworks or to propagate state changes to dependent systems.\n *\n * @internal\n */\nexport type Listener = () => void;\n\n/**\n * Simple reactive state store interface with subscription-based change notification.\n *\n * @remarks\n * This interface defines a lightweight state management container that provides:\n * - Direct state access via {@link ListStore.getState}\n * - Immutable state updates via {@link ListStore.setState}\n * - Change notification via {@link ListStore.subscribe}\n *\n * The store follows a publish-subscribe pattern where state mutations trigger notifications\n * to all registered listeners. State updates use an updater function pattern to ensure\n * immutability and prevent accidental direct mutations.\n *\n * The store performs reference equality checks using `Object.is()` to avoid unnecessary\n * notifications when the new state is identical to the previous state. This optimization\n * helps prevent redundant reactive updates in connected systems.\n *\n * Implementations are created via the {@link createListStore} factory function.\n *\n * @typeParam TState - The type of the state object managed by the store\n *\n * @internal\n */\nexport interface ListStore<TState> {\n    /**\n     * Retrieves the current state snapshot.\n     *\n     * @remarks\n     * This method returns the current state object stored in the store. The returned\n     * state should be treated as immutable and should not be modified directly.\n     * To update the state, use the {@link ListStore.setState} method instead.\n     *\n     * @returns The current state object\n     */\n    getState(): TState;\n\n    /**\n     * Updates the state immutably using an updater function pattern.\n     *\n     * @remarks\n     * This method accepts an updater function that receives the previous state and returns\n     * the next state. The updater function should not mutate the previous state directly but\n     * instead return a new state object with the desired changes.\n     *\n     * After computing the new state, the method performs a reference equality check using\n     * `Object.is()`. If the new state is referentially identical to the previous state,\n     * no listeners are notified and the method returns early. This optimization prevents\n     * unnecessary reactive updates when the state hasn't actually changed.\n     *\n     * If the state has changed, all registered listeners are notified synchronously by\n     * invoking their callback functions in the order they were registered.\n     *\n     * @param updater - Function that receives the previous state and returns the new state\n     */\n    setState(updater: (prev: TState) => TState): void;\n\n    /**\n     * Registers a listener for state change notifications.\n     *\n     * @remarks\n     * This method adds a listener function to the store's subscription set. The listener\n     * will be invoked synchronously whenever the state changes via {@link ListStore.setState}.\n     * Listeners receive no parameters and are expected to retrieve the current state via\n     * {@link ListStore.getState} if needed.\n     *\n     * The method returns an unsubscribe function that removes the listener from the subscription\n     * set when called. It is safe to call the unsubscribe function multiple times; subsequent\n     * calls have no effect.\n     *\n     * @param listener - The callback function to invoke on state changes\n     * @returns A function that unsubscribes the listener when called\n     */\n    subscribe(listener: Listener): () => void;\n}\n\n/**\n * Creates a new reactive state store with the given initial state.\n *\n * @remarks\n * This factory function creates a {@link ListStore} instance initialized with the provided\n * initial state. The returned store is a lightweight reactive container that manages state\n * using a simple publish-subscribe pattern.\n *\n * The store implementation uses:\n * - A closure-captured `state` variable to hold the current state\n * - A `Set` to maintain registered listeners for efficient subscription management\n * - `Object.is()` for reference equality checks to optimize notification performance\n *\n * The store performs reference equality optimization, meaning that if a state update\n * produces a referentially identical state object, no listeners will be notified. This\n * behavior encourages immutable update patterns and prevents unnecessary reactive updates.\n *\n * Example usage:\n * ```typescript\n * interface AppState {\n *   count: number;\n *   items: string[];\n * }\n *\n * const store = createListStore<AppState>({ count: 0, items: [] });\n *\n * // Subscribe to changes\n * const unsubscribe = store.subscribe(() => {\n *   console.log('State changed:', store.getState());\n * });\n *\n * // Update state immutably\n * store.setState(prev => ({ ...prev, count: prev.count + 1 }));\n *\n * // Clean up\n * unsubscribe();\n * ```\n *\n * @typeParam TState - The type of the state object managed by the store\n * @param initialState - The initial state value for the store\n * @returns A new ListStore instance initialized with the provided state\n *\n * @internal\n */\nexport function createListStore<TState>(initialState: TState): ListStore<TState> {\n    let state = initialState;\n    const listeners = new Set<Listener>();\n\n    return {\n        getState() {\n            return state;\n        },\n\n        setState(updater) {\n            const next = updater(state);\n            if (Object.is(next, state)) return;\n            state = next;\n            for (const l of listeners) l();\n        },\n\n        subscribe(listener) {\n            listeners.add(listener);\n            return () => {\n                listeners.delete(listener);\n            };\n        },\n    };\n}\n","import {ListFeatureContext} from \"../context/listFeatureContext\";\nimport {FeatureUIContract} from \"../contracts/featureUIContract\";\n\n/**\n * Compiled execution plan containing ordered collections of feature functions and APIs.\n *\n * @remarks\n * This interface represents the result of the feature compilation process, where all registered\n * features have been resolved, ordered according to their dependencies, and organized into\n * separate execution pipelines for each processing stage. The compiled plan serves as an\n * optimized blueprint for creating runtime instances that execute features in the correct order.\n *\n * The compilation process performs the following operations:\n * - Topologically sorts features based on their declared dependencies\n * - Collects and orders functions for each lifecycle hook (init, destroy, refresh)\n * - Assembles the data derivation pipeline in dependency order\n * - Aggregates feature-specific APIs into a unified registry\n * - Gathers UI contracts for rendering coordination\n *\n * This compiled plan is immutable and can be reused to create multiple runtime instances,\n * making it suitable for scenarios where the same feature configuration is applied to\n * different data sources or contexts.\n *\n * @typeParam TRow - The type of individual row data objects in the list\n *\n * @see {@link ListRuntimePlan} for the executable runtime instance created from this plan\n * @see {@link createRuntimePlan} for the function that converts a compiled plan into a runtime\n *\n * @internal\n */\nexport interface CompiledFeaturePlan<TRow = any> {\n    /**\n     * Ordered pipeline of data transformation functions for row derivation.\n     *\n     * @remarks\n     * This array contains functions from the \"derive\" stage of all compiled features,\n     * ordered according to feature dependencies. Each function in the pipeline receives\n     * the current row array and the feature context, and returns a transformed row array.\n     *\n     * The pipeline executes sequentially, with each function's output becoming the input\n     * for the next function. This enables features to:\n     * - Add computed properties to rows\n     * - Filter or reorder rows\n     * - Transform existing row data\n     * - Enrich rows with additional information\n     *\n     * The derivation pipeline runs before any lifecycle hooks or UI rendering, ensuring\n     * that all derived data is available when needed by other features or components.\n     */\n    derivePipeline: Array<\n        (rows: readonly TRow[], ctx: ListFeatureContext<TRow>) => readonly TRow[]\n    >;\n\n    /**\n     * Ordered collection of initialization functions to execute during list setup.\n     *\n     * @remarks\n     * This array contains onInit functions from the \"lifecycle\" stage of all compiled features,\n     * ordered according to feature dependencies. Each function receives the feature context\n     * and may perform asynchronous initialization operations.\n     *\n     * Initialization functions typically:\n     * - Set up initial feature state\n     * - Register event listeners or subscriptions\n     * - Perform one-time computations\n     * - Load persisted state or configuration\n     *\n     * All initialization functions are executed sequentially in order, with each function\n     * awaited before proceeding to the next. This ensures that features with dependencies\n     * are fully initialized before dependent features begin their initialization.\n     */\n    onInit: Array<(ctx: ListFeatureContext<TRow>) => void | Promise<void>>;\n\n    /**\n     * Ordered collection of cleanup functions to execute during list teardown.\n     *\n     * @remarks\n     * This array contains onDestroy functions from the \"lifecycle\" stage of all compiled features,\n     * ordered according to feature dependencies. Each function receives the feature context\n     * and performs synchronous cleanup operations.\n     *\n     * Cleanup functions typically:\n     * - Unregister event listeners or subscriptions\n     * - Cancel pending operations\n     * - Release allocated resources\n     * - Clear timers or intervals\n     *\n     * All cleanup functions are executed sequentially in order, with errors caught and\n     * suppressed to ensure that one feature's cleanup failure does not prevent other\n     * features from cleaning up properly.\n     */\n    onDestroy: Array<(ctx: ListFeatureContext<TRow>) => void>;\n\n    /**\n     * Ordered collection of refresh functions to execute during data refresh operations.\n     *\n     * @remarks\n     * This array contains onRefresh functions from the \"lifecycle\" stage of all compiled features,\n     * ordered according to feature dependencies. Each function receives the feature context\n     * and may perform asynchronous refresh operations.\n     *\n     * Refresh functions typically:\n     * - Update derived state based on new data\n     * - Recalculate cached values\n     * - Synchronize with external data sources\n     * - Reset transient state\n     *\n     * All refresh functions are executed sequentially in order, with each function awaited\n     * before proceeding to the next. This ensures that features can depend on other features\n     * having completed their refresh operations.\n     */\n    onRefresh: Array<(ctx: ListFeatureContext<TRow>) => void | Promise<void>>;\n\n    /**\n     * Registry of feature-specific APIs exposed by compiled features.\n     *\n     * @remarks\n     * This object contains the public APIs exported by each compiled feature, indexed by\n     * feature name or identifier. Features register their APIs during compilation, making\n     * them accessible to other features and external consumers through the context's\n     * features property.\n     *\n     * Feature APIs may include:\n     * - Methods for programmatic interaction with the feature\n     * - State accessors for reading feature-specific state\n     * - Configuration objects\n     * - Event emitters or observables\n     *\n     * The registry is created with a null prototype to prevent prototype chain pollution\n     * and ensure predictable property access behavior.\n     */\n    featureApis: Record<string, unknown>;\n\n    /**\n     * Collection of UI contracts defining rendering requirements for each feature.\n     *\n     * @remarks\n     * This object maps feature identifiers to their UI contracts, which describe how\n     * the feature should be rendered in the user interface. UI contracts from the \"ui\"\n     * stage define rendering slots, component factories, and other UI-related metadata.\n     *\n     * UI contracts typically specify:\n     * - Component types or factories for rendering\n     * - Rendering priorities or ordering\n     * - Slot identifiers for component placement\n     * - Styling or theming requirements\n     *\n     * Entries may be undefined if a feature does not provide a UI contract. The contracts\n     * are used by rendering layers to coordinate feature visualization and ensure proper\n     * component composition.\n     */\n    uiContracts: Record<string, FeatureUIContract | undefined>;\n}\n\n/**\n * Executable runtime instance that orchestrates feature execution and lifecycle management.\n *\n * @remarks\n * This interface represents an executable runtime created from a compiled feature plan.\n * It provides methods for executing the various feature pipelines and managing the feature\n * lifecycle, while maintaining references to the feature context and exposed APIs.\n *\n * The runtime instance is created by {@link createRuntimePlan} and serves as the primary\n * interface for interacting with compiled features during list operation. It encapsulates\n * the execution logic for:\n * - Data derivation through the transformation pipeline\n * - Lifecycle management (initialization, refresh, destruction)\n * - Access to feature APIs and UI contracts\n *\n * Runtime instances are typically created once per list instance and remain active for\n * the lifetime of the list. The runtime maintains stable references to ensure consistent\n * behavior across component renders and state updates.\n *\n * @typeParam TRow - The type of individual row data objects in the list\n *\n * @see {@link CompiledFeaturePlan} for the compiled plan that generates this runtime\n * @see {@link createRuntimePlan} for the factory function that creates runtime instances\n *\n * @internal\n */\nexport interface ListRuntimePlan<TRow = any> {\n    /**\n     * The feature context object shared across all features.\n     *\n     * @remarks\n     * This property provides direct access to the feature context that was passed to\n     * {@link createRuntimePlan} during runtime creation. The context serves as the central\n     * coordination point for state management, feature communication, and data operations.\n     *\n     * The context remains stable by reference throughout the runtime lifetime, though its\n     * internal state properties may change. Features and external consumers can use this\n     * reference to access state, invoke refresh operations, or interact with registered\n     * feature APIs.\n     */\n    readonly ctx: ListFeatureContext<TRow>;\n\n    /**\n     * Registry of feature-specific APIs accessible to consumers.\n     *\n     * @remarks\n     * This property provides direct access to the feature API registry from the context's\n     * features property. It contains the public APIs exported by all compiled features,\n     * indexed by feature name or identifier.\n     *\n     * This convenience property eliminates the need to access the registry through\n     * `ctx.features`, making feature APIs more easily discoverable and accessible to\n     * external consumers.\n     */\n    readonly features: Record<string, unknown>;\n\n    /**\n     * Executes the data derivation pipeline to transform row data.\n     *\n     * @remarks\n     * This method runs all data transformation functions from the compiled derivation\n     * pipeline in sequence, passing the output of each function as input to the next.\n     * The pipeline processes row data through all registered derive-stage features in\n     * dependency order.\n     *\n     * The derivation process:\n     * - Receives an input array of rows\n     * - Applies each transformation function sequentially\n     * - Returns the final transformed row array\n     * - Maintains row immutability (functions return new arrays)\n     *\n     * This method should be called whenever row data changes or when derived properties\n     * need to be recalculated. The derived data is typically used for rendering, filtering,\n     * sorting, or other data-dependent operations.\n     *\n     * @param rows - The input array of row data to transform\n     * @returns The transformed array of row data after all derivation functions are applied\n     */\n    derive: (rows: readonly TRow[]) => readonly TRow[];\n\n    /**\n     * Initializes all features by executing their onInit lifecycle hooks.\n     *\n     * @remarks\n     * This method runs all initialization functions from the compiled onInit collection\n     * in sequence, awaiting each function before proceeding to the next. Initialization\n     * establishes the initial state and configuration for all features.\n     *\n     * The initialization process:\n     * - Executes onInit functions in dependency order\n     * - Awaits asynchronous initialization operations\n     * - Ensures dependent features initialize after their dependencies\n     * - Completes before the list becomes interactive\n     *\n     * This method should be called once during list setup, typically after the context\n     * is created but before any data operations or rendering occurs. Initialization\n     * failures may prevent the list from functioning correctly.\n     *\n     * @returns A promise that resolves when all initialization functions have completed\n     */\n    init: () => Promise<void>;\n\n    /**\n     * Refreshes all features by executing their onRefresh lifecycle hooks.\n     *\n     * @remarks\n     * This method runs all refresh functions from the compiled onRefresh collection in\n     * sequence, awaiting each function before proceeding to the next. Refresh operations\n     * update feature state and derived data in response to data source changes.\n     *\n     * The refresh process:\n     * - Executes onRefresh functions in dependency order\n     * - Awaits asynchronous refresh operations\n     * - Ensures dependent features refresh after their dependencies\n     * - Typically triggered by data source changes or manual refresh requests\n     *\n     * This method is called through the context's refresh function and may be invoked\n     * multiple times throughout the list lifetime. Features should implement idempotent\n     * refresh logic that safely handles repeated invocations.\n     *\n     * @returns A promise that resolves when all refresh functions have completed\n     */\n    refresh: () => Promise<void>;\n\n    /**\n     * Destroys all features by executing their onDestroy lifecycle hooks.\n     *\n     * @remarks\n     * This method runs all cleanup functions from the compiled onDestroy collection in\n     * sequence, catching and suppressing any errors to ensure all features have an\n     * opportunity to clean up. Destruction releases resources and removes event listeners.\n     *\n     * The destruction process:\n     * - Executes onDestroy functions in dependency order\n     * - Catches and suppresses errors from individual functions\n     * - Ensures all cleanup attempts complete regardless of failures\n     * - Typically called once during list unmounting or disposal\n     *\n     * This method should be called when the list is being torn down or removed from the\n     * DOM. After destruction, the runtime instance should not be used for further operations.\n     * Features should implement cleanup logic that safely handles being called multiple times.\n     */\n    destroy: () => void;\n\n    /**\n     * Collection of UI contracts defining rendering requirements for each feature.\n     *\n     * @remarks\n     * This property provides access to the UI contracts from the compiled feature plan,\n     * which describe how features should be rendered in the user interface. The contracts\n     * are passed directly from the compiled plan without modification.\n     *\n     * UI contracts are used by rendering layers to:\n     * - Determine which components to render for each feature\n     * - Coordinate component placement and ordering\n     * - Apply feature-specific styling or theming\n     * - Manage rendering slots and composition\n     *\n     * Entries may be undefined if a feature does not provide a UI contract.\n     */\n    uiContracts: Record<string, FeatureUIContract | undefined>;\n}\n\n\n/**\n * Creates an executable runtime instance from a compiled feature plan and context.\n *\n * @remarks\n * This factory function transforms a compiled feature plan into an executable runtime\n * by binding the plan's function collections to a specific feature context. The resulting\n * runtime instance provides methods for executing feature pipelines and managing the\n * feature lifecycle.\n *\n * The creation process performs the following operations:\n * 1. Creates immutable frozen copies of all function arrays to prevent runtime modification\n * 2. Registers all feature APIs into the context's features registry\n * 3. Defines execution methods that iterate through function collections\n * 4. Returns a runtime object with stable references for lifecycle management\n *\n * The created runtime encapsulates the execution logic for:\n * - **derive**: Sequentially applies all derivation functions to transform row data\n * - **init**: Sequentially executes and awaits all initialization functions\n * - **refresh**: Sequentially executes and awaits all refresh functions\n * - **destroy**: Sequentially executes all cleanup functions with error suppression\n *\n * Function arrays are frozen to ensure the execution order cannot be modified after\n * runtime creation, maintaining the dependency-based ordering established during\n * compilation. This immutability prevents runtime bugs caused by unexpected function\n * collection mutations.\n *\n * Feature APIs are merged into the context's features registry using Object.assign,\n * making them accessible to all features and external consumers through a shared\n * reference. This enables cross-feature communication and programmatic feature control.\n *\n * Error handling strategy:\n * - Initialization and refresh functions propagate errors to callers\n * - Destruction functions suppress all errors to ensure complete cleanup\n * - Derivation functions should handle errors internally or propagate them\n *\n * @typeParam TRow - The type of individual row data objects in the list\n *\n * @param ctx - The feature context providing state management and coordination\n * @param compiled - The compiled feature plan containing ordered function collections\n *\n * @returns An executable runtime instance bound to the provided context\n *\n * @see {@link CompiledFeaturePlan} for the structure of compiled feature plans\n * @see {@link ListRuntimePlan} for the structure of the returned runtime instance\n * @see {@link ListFeatureContext} for the context object interface\n *\n * @internal\n */\nexport function createRuntimePlan<TRow = any>(\n    ctx: ListFeatureContext<TRow>,\n    compiled: CompiledFeaturePlan<TRow>\n): ListRuntimePlan<TRow> {\n    const derivePipeline = Object.freeze([...compiled.derivePipeline]);\n    const onInit = Object.freeze([...compiled.onInit]);\n    const onDestroy = Object.freeze([...compiled.onDestroy]);\n    const onRefresh = Object.freeze([...compiled.onRefresh]);\n\n    Object.assign(ctx.features, compiled.featureApis);\n\n    const derive = (rows: readonly TRow[]): readonly TRow[] => {\n        let out = rows;\n        for (const step of derivePipeline) {\n            out = step(out, ctx);\n        }\n        return out;\n    };\n\n    const init = async (): Promise<void> => {\n        for (const fn of onInit) {\n            await fn(ctx);\n        }\n    };\n\n    const refresh = async (): Promise<void> => {\n        for (const fn of onRefresh) {\n            await fn(ctx);\n        }\n    };\n\n    const destroy = (): void => {\n        for (const fn of onDestroy) {\n            try {\n                fn(ctx);\n            } catch {\n            }\n        }\n    };\n\n    return {\n        ctx,\n        features: ctx.features,\n        derive,\n        init,\n        refresh,\n        destroy,\n        uiContracts: compiled.uiContracts\n    };\n}\n","import {FeatureRegistry} from \"../registry/featureRegistryType\";\nimport {CompiledFeaturePlan, createRuntimePlan, ListRuntimePlan} from \"../registry/compiledFeaturePlan\";\nimport {ListFeatureContext, SetStateFn} from \"./listFeatureContext\";\n\n/**\n * Configuration arguments for creating a list runtime instance.\n *\n * @remarks\n * This type defines all required dependencies and callbacks needed to initialize\n * a list runtime environment that manages feature execution and state coordination.\n *\n * @typeParam TRow - The type of individual row data items in the list\n * @typeParam TRowId - The type used to uniquely identify rows\n * @typeParam TState - The type of the internal state object managed by the runtime\n * @typeParam TSnapshot - The type of the exported state snapshot representation\n *\n * @internal\n */\nexport type CreateListRuntimeArgs<\n    TRow = any,\n    TRowId = any,\n    TState = unknown,\n    TSnapshot = unknown\n> = {\n    /**\n     * The feature registry containing all registered features to be compiled and executed.\n     */\n    registry: FeatureRegistry<TRow, TRowId>;\n\n    /**\n     * A mutable reference object holding the current state, enabling external state tracking.\n     */\n    stateRef: { current: TState };\n\n    /**\n     * Callback function to update the state, typically used to trigger re-renders in UI frameworks.\n     */\n    setState: SetStateFn<TState>;\n\n    /**\n     * Implementation function that performs a refresh operation, typically refetching or recalculating data.\n     */\n    refreshImpl: () => Promise<void>;\n\n    /**\n     * Implementation function that exports the current state as a snapshot for serialization or persistence.\n     */\n    exportStateImpl: () => TSnapshot;\n\n    /**\n     * Optional metadata object containing additional context information such as field definitions and ID key mappings.\n     */\n    meta?: ListFeatureContext<TRow, TRowId, TState, TSnapshot>[\"meta\"];\n};\n\n/**\n * Creates a list runtime execution plan by compiling registered features and establishing the execution context.\n *\n * @remarks\n * This function serves as the primary factory for instantiating list runtime environments. It constructs\n * a feature context from the provided dependencies, compiles all registered features through the registry,\n * and produces a runtime plan that coordinates feature execution and state management throughout the\n * list's lifecycle.\n *\n * The function performs the following operations:\n * 1. Constructs a ListFeatureContext with all necessary state management callbacks\n * 2. Compiles the feature registry to produce a CompiledFeaturePlan\n * 3. Creates and returns a ListRuntimePlan that orchestrates feature execution\n *\n * @typeParam TRow - The type of individual row data items in the list\n * @typeParam TRowId - The type used to uniquely identify rows\n * @typeParam TState - The type of the internal state object managed by the runtime\n * @typeParam TSnapshot - The type of the exported state snapshot representation\n *\n * @param args - Configuration object containing all required dependencies and callbacks\n * @returns A ListRuntimePlan instance that manages feature execution and provides access to compiled feature APIs\n *\n * @internal\n */\nexport function createListRuntime<\n    TRow = any,\n    TRowId = any,\n    TState = unknown,\n    TSnapshot = unknown\n>(args: CreateListRuntimeArgs<TRow, TRowId, TState, TSnapshot>): ListRuntimePlan<TRow> {\n\n    const {registry, stateRef, setState, refreshImpl, exportStateImpl, meta} = args;\n    const ctx: ListFeatureContext<TRow, TRowId, TState, TSnapshot> = {\n        state: stateRef.current,\n        stateRef,\n        setState,\n        refresh: refreshImpl,\n        exportState: exportStateImpl,\n        features: Object.create(null),\n        meta,\n    };\n    const compiled: CompiledFeaturePlan<TRow> = registry.compile(ctx as any);\n    return createRuntimePlan<TRow>(ctx as any, compiled);\n}\n","import type { ListSlots } from \"./listSlots\";\nimport {ListRuntimePlan} from \"../registry/compiledFeaturePlan\";\n\n/**\n * Configuration options for UI wiring validation behavior.\n *\n * @remarks\n * This type defines the configuration options that control how the UI wiring validation\n * process behaves when validating the connection between UI components and their required\n * feature handler implementations. It provides flexibility in handling validation failures\n * and allows conditional disabling of validation in specific environments.\n *\n * The validation system ensures that when UI components are rendered in specific slots,\n * all required handler methods are properly implemented in the feature API. This prevents\n * runtime errors caused by missing handler implementations.\n *\n * @internal\n */\nexport type UiWiringValidationOptions = {\n    /**\n     * Determines the validation failure behavior mode.\n     *\n     * @remarks\n     * Controls how the validation system responds when it detects invalid UI wiring:\n     * - `\"throw\"` (default): Throws an error immediately, preventing execution\n     * - `\"warn\"`: Logs a warning to console but allows execution to continue\n     *\n     * Use `\"throw\"` mode in development to catch wiring errors early. Use `\"warn\"` mode\n     * in scenarios where you want to log issues without blocking execution, though this\n     * is generally not recommended as it may lead to runtime errors when handlers are invoked.\n     *\n     * @defaultValue `\"throw\"`\n     */\n    mode?: \"throw\" | \"warn\";\n\n    /**\n     * Controls whether validation is performed at all.\n     *\n     * @remarks\n     * When set to `false`, the validation process is completely skipped. This can be useful\n     * in production environments where validation overhead is undesirable and you have high\n     * confidence in the correctness of your UI wiring through comprehensive testing.\n     *\n     * **Warning**: Disabling validation in production removes an important safety check.\n     * Only disable validation if you have thorough automated tests covering all UI wiring\n     * scenarios and accept the risk of potential runtime errors from missing handlers.\n     *\n     * @defaultValue `true`\n     */\n    enabled?: boolean;\n};\n\n/**\n * Checks whether any of the specified slot names have corresponding components defined.\n *\n * @remarks\n * This utility function determines if at least one slot from a provided list of slot names\n * has an associated component in the components registry. It performs a shallow existence\n * check and returns `true` as soon as the first matching slot is found, optimizing for\n * early termination.\n *\n * The function is used during validation to determine whether a feature's UI is \"active\"\n * (i.e., whether any of its declared slots have been populated with actual components).\n * If no slots are active, validation of handler requirements is skipped for that feature.\n *\n * @param components - The components registry mapping slot names to component implementations\n * @param slots - Optional array of slot names to check for existence in the components registry\n *\n * @returns `true` if at least one slot from the provided array exists in the components registry,\n *          `false` if the slots array is undefined, empty, or none of the slots exist\n *\n * @internal\n */\nfunction hasAnySlot(components: ListSlots, slots?: string[]): boolean {\n    if (!slots || slots.length === 0) return false;\n    for (const s of slots) {\n        if (components[s]) return true;\n    }\n    return false;\n}\n\n/**\n * Type guard function that checks whether a value is a function.\n *\n * @remarks\n * This utility function performs a runtime type check to determine if the provided value\n * is a function type. It uses TypeScript's type predicate feature to narrow the type of\n * the value in subsequent code when the check returns `true`.\n *\n * The function is used during validation to verify that required handler methods are\n * actually functions rather than other types of values (undefined, null, objects, etc.).\n * This ensures that handlers can be safely invoked by UI components.\n *\n * @param value - The value to check for function type\n *\n * @returns `true` if the value is a function, `false` otherwise. When `true`, TypeScript\n *          narrows the type to `(...args: any[]) => any`\n *\n * @internal\n */\nfunction isFunction(value: unknown): value is (...args: any[]) => any {\n    return typeof value === \"function\";\n}\n\n/**\n * Validates that all UI components have their required feature handler implementations available.\n *\n * @remarks\n * This function performs comprehensive validation of the UI wiring contract, ensuring that when\n * UI components are rendered in specific slots, all handler methods required by those components\n * are properly implemented in the corresponding feature APIs. This validation prevents runtime\n * errors that would occur if UI components attempted to invoke missing or incorrectly typed handlers.\n *\n * The validation process works as follows:\n *\n * 1. **Contract Discovery**: Examines the `uiContracts` metadata in the runtime plan, which maps\n *    feature IDs to their UI contract specifications (declared slots and required handlers)\n *\n * 2. **Active UI Detection**: For each feature contract, checks if any of the feature's declared\n *    slots have actual components rendered using {@link hasAnySlot}. If no slots are active,\n *    validation is skipped for that feature (no UI = no handler requirements)\n *\n * 3. **Feature API Verification**: Confirms that the feature API exists in the runtime's feature\n *    registry (`runtime.features[featureId]`). Reports an error if UI slots are active but the\n *    API is missing\n *\n * 4. **Handler Implementation Check**: For each required handler specified in the contract,\n *    verifies that the handler exists on the feature API and is a function using {@link isFunction}.\n *    Reports an error for any missing or non-function handlers\n *\n * 5. **Error Reporting**: Collects all validation errors and either throws an error or logs a\n *    warning based on the configured mode\n *\n * **Usage Pattern:**\n *\n * This function should be called **exactly once** during the initialization phase when assembling\n * the list display, typically inside the `ListDisplay` component after the runtime plan and slot\n * components have been prepared but before rendering begins. Calling it multiple times is\n * unnecessary and adds validation overhead.\n *\n * ```typescript\n * function ListDisplay() {\n *   const runtime = useListRuntime();\n *   const components = useListSlots();\n *\n *   validateUiWiring(runtime, components, {\n *     mode: \"throw\",\n *     enabled: process.env.NODE_ENV !== \"production\"\n *   });\n *\n *   return <List runtime={runtime} slots={components} />;\n * }\n * ```\n *\n * **Error Messages:**\n *\n * When validation fails, error messages clearly identify:\n * - The feature ID with invalid wiring\n * - The specific slots that are active\n * - Missing feature APIs or handler implementations\n * - The exact handler names that are missing or incorrectly typed\n *\n * @param runtime - The compiled runtime plan containing feature APIs and UI contracts metadata\n * @param components - The registry of UI components mapped to their slot names\n * @param options - Optional configuration controlling validation behavior (mode and enabled flag)\n *\n * @throws {Error} When validation fails and `options.mode` is `\"throw\"` (default), throws an\n *                 error with a detailed message listing all validation failures\n *\n * @see {@link UiWiringValidationOptions} for configuration options\n * @see {@link ListRuntimePlan} for the runtime plan structure\n * @see {@link ListSlots} for the slot component registry structure\n *\n * @internal\n */\nexport function validateUiWiring(\n    runtime: ListRuntimePlan<any>,\n    components: ListSlots,\n    options: UiWiringValidationOptions = {}\n): void {\n    const { mode = \"throw\", enabled = true } = options;\n    if (!enabled) return;\n\n    const uiContracts = (runtime as any).uiContracts as Record<\n        string,\n        { slots?: string[]; requiredHandlers?: string[] } | undefined\n    >;\n\n    if (!uiContracts) return;\n\n    const errors: string[] = [];\n\n    for (const [featureId, contract] of Object.entries(uiContracts)) {\n        if (!contract) continue;\n\n        const uiActive = hasAnySlot(components, contract.slots);\n        if (!uiActive) continue;\n\n        const api = runtime.features?.[featureId];\n        if (!api) {\n            errors.push(\n                `Feature '${featureId}' declares UI slots [${(contract.slots ?? []).join(\", \")}] ` +\n                `but no API was created (ctx.features['${featureId}'] is missing).`\n            );\n            continue;\n        }\n\n        for (const handlerName of contract.requiredHandlers ?? []) {\n            const candidate = (api as any)[handlerName];\n            if (!isFunction(candidate)) {\n                errors.push(\n                    `Feature '${featureId}' UI requires handler '${handlerName}', ` +\n                    `but ctx.features['${featureId}'].${handlerName} is missing or not a function.`\n                );\n            }\n        }\n    }\n\n    if (errors.length === 0) return;\n\n    const message =\n        `ListDisplay UI wiring is invalid:\\n` +\n        errors.map((e) => `- ${e}`).join(\"\\n\");\n\n    if (mode === \"warn\") {\n        console.warn(message);\n        return;\n    }\n\n    throw new Error(message);\n}\n","import React, {createContext, useContext} from \"react\";\nimport type {ListFeatureContext} from \"./listFeatureContext\";\n\n/**\n * Core context type used by all list component slots for accessing shared list state and features.\n *\n * @remarks\n * This type is an alias for {@link ListFeatureContext} and represents the stable context reference\n * passed through React Context. The context itself remains stable by reference across renders,\n * while the actual state mutations are tracked via the `stateRef.current` property to avoid\n * unnecessary re-renders.\n *\n * @typeParam TRow - The type of individual row data objects in the list\n * @typeParam TRowId - The type used for unique row identifiers (typically string or number)\n * @typeParam TState - The shape of the internal list state object\n * @typeParam TSnapshot - The type of the exported/serialized state snapshot\n *\n * @internal\n */\nexport type ListCtx<\n    TRow = any, TRowId = any, TState = any, TSnapshot = any\n> =\n    ListFeatureContext<TRow, TRowId, TState, TSnapshot>;\n\nconst ListContext = createContext<ListCtx<any, any, any, any> | null>(null);\n\n/**\n * Provider component that supplies the list context to all descendant components.\n *\n * @remarks\n * This component wraps the React Context Provider for {@link ListCtx}. All list-related\n * components and hooks must be rendered within this provider to access the list context.\n * The provider accepts a single context value that is stable by reference and shares\n * state, features, and utility methods with all consuming components.\n *\n * @param props - Component props\n * @param props.value - The list context object containing state, features, and methods\n * @param props.children - React children to be rendered within the provider\n *\n * @returns The context provider with children\n *\n * @example\n * ```tsx\n * <ListContextProvider value={listContext}>\n *   <DefaultTable />\n * </ListContextProvider>\n * ```\n *\n * @internal\n */\nexport function ListContextProvider(props: {\n    value: ListCtx<any, any, any, any>;\n    children: React.ReactNode;\n}) {\n    return <ListContext.Provider value={props.value}>{props.children}</ListContext.Provider>;\n}\n\n/**\n * React hook that retrieves the current list context.\n *\n * @remarks\n * This hook provides access to the list context object which includes the current state,\n * state reference, state setter, refresh function, export function, features registry,\n * and metadata. The hook must be called within a component that is a descendant of\n * {@link ListContextProvider}, otherwise it will throw an error.\n *\n * The returned context object is stable by reference, but its `stateRef.current` property\n * may change between renders. Components should access state through the context's `state`\n * property for reactive updates or `stateRef.current` for non-reactive access.\n *\n * @typeParam TRow - The type of individual row data objects in the list\n * @typeParam TRowId - The type used for unique row identifiers\n * @typeParam TState - The shape of the internal list state object\n * @typeParam TSnapshot - The type of the exported/serialized state snapshot\n *\n * @returns The current list context object\n *\n * @throws {@link Error}\n * Throws an error if called outside of a {@link ListContextProvider}\n *\n * @example\n * ```tsx\n * function MyListComponent() {\n *   const ctx = useListCtx();\n *   const rows = ctx.state.rows;\n *   return <div>{rows.length} items</div>;\n * }\n * ```\n *\n * @internal\n */\nexport function useListCtx<\n    TRow = any,\n    TRowId = any,\n    TState = any,\n    TSnapshot = any\n>(): ListCtx<TRow, TRowId, TState, TSnapshot> {\n    const ctx = useContext(ListContext);\n    if (!ctx) {\n        throw new Error(\"useListCtx() must be used inside <ListContextProvider>.\");\n    }\n    return ctx as any;\n}\n","import React, { useEffect, useMemo, useRef } from \"react\";\nimport { useSyncExternalStore } from \"react\";\nimport {FeatureRegistry} from \"./core/registry/featureRegistryType\";\nimport {ApplyPatchFn, DataSource, useListEngine} from \"./core/engine/useListEngine\";\nimport {ListSlots} from \"./core/contracts/listSlots\";\nimport {CoreListState} from \"./core/store/coreState\";\nimport {createListStore} from \"./core/store/listStore\";\nimport {ListRuntimePlan} from \"./core/registry/compiledFeaturePlan\";\nimport {createListRuntime} from \"./core/context/createListRuntime\";\nimport {validateUiWiring} from \"./core/contracts/validateUiWiring\";\nimport {ListContextProvider} from \"./core/context/listContext\";\nimport {SetStateFn} from \"./core/context/listFeatureContext\";\n\n\n/**\n * Props interface for the ListDisplay component.\n *\n * @remarks\n * This is the main configuration interface for the ListDisplay component, which is the\n * central component of the library. It defines all necessary properties including data\n * management, feature registry, UI components, and optional optimizations.\n *\n * @typeParam TRow - The type of row data being displayed in the list\n * @typeParam TRowId - The type of the unique identifier for each row\n * @typeParam TPatch - The type of patch data used for optimistic updates\n *\n * @public\n */\nexport type ListDisplayProps<TRow = any, TRowId = any, TPatch = unknown> = {\n    /**\n     * The key name used to uniquely identify each row in the data.\n     *\n     * @remarks\n     * This property specifies which field in your row data serves as the unique identifier.\n     * It's used internally for efficient row tracking and updates.\n     *\n     * @example\n     * ```typescript\n     * idKey: \"id\"\n     * idKey: \"userId\"\n     * ```\n     */\n    idKey: string;\n\n    /**\n     * The field schema definition for the list columns.\n     *\n     * @remarks\n     * This property defines the structure and metadata of the fields/columns in your list.\n     * The exact type will be tightened to FieldSchema<TRow>[] in future versions.\n     * Currently accepts any field definition structure.\n     */\n    fields: unknown;\n\n    /**\n     * The data source provider for fetching and managing list data.\n     *\n     * @remarks\n     * This is a required function or object that defines how the list fetches its data.\n     * It handles initial data loading, refreshes, and any server communication.\n     * The data source is the primary input for the list's data pipeline.\n     */\n    dataSource: DataSource<TRow, TPatch>;\n\n    /**\n     * Optional function to apply optimistic patch updates to rows.\n     *\n     * @remarks\n     * When provided, this function enables optimistic updates by applying patch data\n     * to existing rows before the server confirms the changes. This improves perceived\n     * performance by immediately reflecting user actions in the UI.\n     */\n    applyPatch?: ApplyPatchFn<TRow, TPatch>;\n\n    /**\n     * The feature registry containing all registered list features.\n     *\n     * @remarks\n     * This is the core registry that defines what capabilities your list has, such as\n     * filtering, sorting, pagination, etc. The registry must be created and configured\n     * before being passed to ListDisplay.\n     *\n     */\n    registry: FeatureRegistry<TRow, TRowId>;\n\n    /**\n     * Optional UI component slots to customize the list's appearance.\n     *\n     * @remarks\n     * Provide custom React components for various parts of the list UI such as\n     * Table, Toolbar, FiltersPanel, Pagination, etc. Any slot not provided will\n     * simply not be rendered, allowing for flexible layouts.\n     */\n    components?: ListSlots;\n\n    /**\n     * Optional props to pass to each component slot.\n     *\n     * @remarks\n     * This object allows you to pass additional props to your custom components.\n     * Keys should match the component slot names (e.g., \"Table\", \"Toolbar\").\n     */\n    componentsProps?: Record<string, unknown>;\n\n    /**\n     * UI wiring validation behavior mode.\n     *\n     * @remarks\n     * Controls how the library validates that required UI handlers are properly wired.\n     * - \"throw\": Throws an error if validation fails (recommended for development)\n     * - \"warn\": Logs a warning if validation fails (recommended for production)\n     *\n     * @defaultValue \"throw\"\n     */\n    validationMode?: \"throw\" | \"warn\";\n\n    /**\n     * Optional initial rows for instant first paint optimization.\n     *\n     * @remarks\n     * When provided, these rows will be displayed immediately without waiting for\n     * the data source to load. This is useful for server-side rendering or when\n     * you already have data available. The list status will be set to \"ready\"\n     * instead of \"idle\" when initial rows are provided.\n     */\n    initialRows?: TRow[];\n};\n\nconst DEFAULT_STATE: CoreListState<any> = {\n    rawRows: [],\n    rows: [],\n    status: \"idle\",\n    featureState: Object.create(null),\n    error: undefined,\n};\n\n/**\n * The main component of the library where all functionality comes together.\n *\n * @remarks\n * ListDisplay is the central orchestrator component that integrates all parts of the list\n * management system. It manages:\n * - Internal state store creation and subscription\n * - Feature registry compilation and runtime initialization\n * - Data source connection and patch application\n * - Lifecycle management (init/destroy) for all features\n * - Derivation pipeline execution (filtering, sorting, pagination, etc.)\n * - UI rendering with customizable component slots\n * - Development-time validation of UI wiring\n *\n * This component creates an isolated list instance with its own internal state management.\n * Parent components remain unaffected by internal state changes. All list features are\n * executed in the correct order as defined by the feature registry, and their APIs are\n * made available through the ListContext to child components.\n *\n * The component handles different loading states automatically and renders appropriate\n * UI based on the current status (loading, error, empty, or ready with data).\n *\n * @typeParam TRow - The type of row data being displayed\n * @typeParam TRowId - The type of the unique identifier for each row\n * @typeParam TPatch - The type of patch data for optimistic updates\n *\n * @param props - Configuration props for the list display\n *\n * @returns A React component that renders the complete list UI\n *\n * @example\n * Basic usage with features:\n * ```typescript\n * import { ListDisplay } from './ListDisplay';\n * import { createRegistry } from './core/registry';\n * import { filteringFeature } from './features/filtering';\n *\n * const registry = createRegistry<User, string>();\n * registry.register(filteringFeature({ apply: myFilterFn }));\n *\n * function MyList() {\n *   return (\n *     <ListDisplay\n *       idKey=\"id\"\n *       fields={fields}\n *       dataSource={fetchUsers}\n *       registry={registry}\n *       components={{ Table: MyTable, Toolbar: MyToolbar }}\n *     />\n *   );\n * }\n * ```\n *\n *\n * @public\n */\nexport function ListDisplay<TRow = any, TRowId = any, TPatch = unknown>(\n    props: ListDisplayProps<TRow, TRowId, TPatch>\n) {\n    const {\n        idKey,\n        fields,\n        dataSource,\n        applyPatch,\n        registry,\n        components = {},\n        componentsProps = {},\n        validationMode = \"throw\",\n        initialRows,\n    } = props;\n\n    // 1) store: created once (internal-only)\n    const storeRef = useRef(\n        createListStore<CoreListState<TRow>>({\n            ...(DEFAULT_STATE as CoreListState<TRow>),\n            rawRows: initialRows ?? [],\n            rows: [],\n            status: initialRows ? \"ready\" : \"idle\",\n        })\n    );\n    const store = storeRef.current;\n\n    // 2) stateRef used by ctx (stable object, mutable current)\n    const stateRef = useRef<CoreListState<TRow>>(store.getState());\n\n    // 3) runtime plan: compiled once\n    const runtimeRef = useRef<ListRuntimePlan<TRow> | null>(null);\n\n    // 4) exportState: for now, minimal (well enhance later)\n    const exportStateImpl = useMemo(() => {\n        return () => {\n            // Return whatever snapshot format youll standardize later.\n            // For now: raw + derived + status.\n            return stateRef.current;\n        };\n    }, []);\n\n    // 5) engine refresh impl (wired after engine hook is created)\n    const refreshRef = useRef<() => Promise<void>>(async () => {});\n\n    const setState: SetStateFn<CoreListState<TRow>> = (updater) => store.setState(updater);\n\n    // 6) compile runtime once (registry must be immutable for this instance)\n    if (!runtimeRef.current) {\n        runtimeRef.current = createListRuntime<TRow, TRowId, CoreListState<TRow>, unknown>({\n            registry,\n            stateRef: stateRef,\n            setState,\n            refreshImpl: () => refreshRef.current(),\n            exportStateImpl,\n            meta: { idKey, fields },\n        }) as any;\n    }\n\n    const runtime = runtimeRef.current!;\n\n    // 7) list engine: init + patches live inside ListDisplay only\n    const { refresh } = useListEngine<TRow, TPatch>({\n        store,\n        dataSource,\n        applyPatch,\n    });\n\n    // connect refresh to runtime ctx\n    refreshRef.current = refresh;\n\n    // 8) subscribe ListDisplay to store updates (parent remains unaffected)\n    const coreState = useSyncExternalStore(\n        store.subscribe,\n        store.getState,\n        store.getState\n    );\n\n    // 9) derive rows through the feature pipeline\n    const derivedRows = runtime.derive(coreState.rawRows);\n\n    // 10) update stateRef.current with latest composite state (stable ctx, mutable current)\n    stateRef.current = {\n        ...coreState,\n        rows: derivedRows as any,\n    };\n\n    // 11) run lifecycle init once + validate UI wiring once\n    useEffect(() => {\n        // init features once\n        runtime.init();\n\n        // validate UI wiring once (dev-time safety)\n        validateUiWiring(runtime as any, components, { mode: validationMode, enabled: true });\n\n        return () => {\n            runtime.destroy();\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    // 12) render: only slots provided\n    const LoadingState = components.LoadingState;\n    const ErrorState = components.ErrorState;\n    const EmptyState = components.EmptyState;\n\n    const Table = components.Table;\n    const Toolbar = components.Toolbar;\n    const FiltersPanel = components.FiltersPanel;\n    const SortBar = components.SortBar;\n    const Pagination = components.Pagination;\n    const ModalOutlet = components.ModalOutlet;\n\n    // status routing (minimal)\n    if (coreState.status === \"loading\" && LoadingState) {\n        return (\n            <ListContextProvider value={runtime.ctx as any}>\n                <LoadingState {...(componentsProps.LoadingState as any)} />\n            </ListContextProvider>\n        );\n    }\n\n    if (coreState.status === \"error\" && ErrorState) {\n        return (\n            <ListContextProvider value={runtime.ctx as any}>\n                <ErrorState {...(componentsProps.ErrorState as any)} />\n            </ListContextProvider>\n        );\n    }\n\n    if (coreState.status === \"ready\" && derivedRows.length === 0 && EmptyState) {\n        return (\n            <ListContextProvider value={runtime.ctx as any}>\n                <EmptyState {...(componentsProps.EmptyState as any)} />\n            </ListContextProvider>\n        );\n    }\n\n    // main layout: render only what exists\n    return (\n        <ListContextProvider value={runtime.ctx as any}>\n            {Toolbar ? <Toolbar {...(componentsProps.Toolbar as any)} /> : null}\n            {FiltersPanel ? <FiltersPanel {...(componentsProps.FiltersPanel as any)} /> : null}\n            {SortBar ? <SortBar {...(componentsProps.SortBar as any)} /> : null}\n            {Table ? <Table {...(componentsProps.Table as any)} /> : null}\n            {Pagination ? <Pagination {...(componentsProps.Pagination as any)} /> : null}\n            {ModalOutlet ? <ModalOutlet {...(componentsProps.ModalOutlet as any)} /> : null}\n        </ListContextProvider>\n    );\n}\n","import type { CoreListState } from \"./coreState\";\n\n/**\n * Retrieves a feature-specific state slice from the core list state, initializing it if not present.\n *\n * @remarks\n * This function provides type-safe access to feature-specific state stored within the shared\n * `featureState` registry of the core list state. Each feature can store its own state slice\n * identified by a unique feature ID, enabling feature isolation and modularity.\n *\n * The function follows a lazy initialization pattern: if the requested feature slice does not\n * exist in the state registry, the provided initializer function is called to create the default\n * state. This approach ensures that feature state is only created when needed and that features\n * can safely access their state without explicit initialization checks.\n *\n * This function is typically called during feature compilation or execution to retrieve the\n * current state slice for a specific feature, which can then be read or updated by feature logic.\n *\n * @typeParam TSlice - The type of the feature-specific state slice being retrieved\n *\n * @param state - The core list state object containing the feature state registry\n * @param featureId - Unique identifier for the feature whose state slice is being retrieved\n * @param init - Initializer function that creates the default state slice if not found\n *\n * @returns The existing feature state slice if present, otherwise the result of calling the init function\n *\n * @internal\n */\nexport function getFeatureSlice<TSlice>(\n  state: CoreListState<any>,\n  featureId: string,\n  init: () => TSlice\n): TSlice {\n  const bag = state.featureState;\n  const existing = bag[featureId];\n  if (existing !== undefined) {\n    return existing as TSlice;\n  }\n  return init();\n}\n\n/**\n * Creates a new state object with an updated feature-specific state slice, maintaining immutability.\n *\n * @remarks\n * This function performs an immutable update operation on the core list state by creating a new\n * state object with an updated feature slice. It preserves all existing state properties while\n * updating only the specified feature's state slice within the `featureState` registry.\n *\n * The function uses object spreading to ensure immutability, which is essential for:\n * - Reactive state management systems that rely on reference equality checks\n * - State change detection in frameworks like React\n * - Enabling proper state history and time-travel debugging\n * - Preventing unintended side effects from shared state mutations\n *\n * Features use this function during state updates to modify their isolated state slice without\n * affecting other features' state or the core list state properties. The updated state is typically\n * passed to the `setState` function from the {@link ListFeatureContext} to trigger re-renders.\n *\n * @typeParam TState - The type of the core list state object, must extend CoreListState\n * @typeParam TSlice - The type of the feature-specific state slice being set\n *\n * @param state - The current core list state object to be updated\n * @param featureId - Unique identifier for the feature whose state slice is being updated\n * @param slice - The new state slice value to store for the specified feature\n *\n * @returns A new state object with the updated feature slice, preserving all other state properties\n *\n * @internal\n */\nexport function setFeatureSlice<TState extends CoreListState<any>, TSlice>(\n  state: TState,\n  featureId: string,\n  slice: TSlice\n): TState {\n  return {\n    ...state,\n    featureState: {\n      ...state.featureState,\n      [featureId]: slice,\n    },\n  };\n}\n","import type {ModalDescriptor, ModalResult} from \"../modals\";\nimport {ListFeatureContext} from \"../../core/context/listFeatureContext\";\nimport {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\nconst FEATURE_ID = \"generalActions\";\n\n/**\n * Context object provided to general action handlers containing list state and utility methods.\n *\n * @public\n * @typeParam TRow - The row data type\n */\nexport type GeneralActionHandlerContext<TRow = any> = {\n    /**\n     * Visible rows after all transformations (filtering, sorting, pagination) have been applied.\n     */\n    rowsVisible: readonly TRow[];\n\n    /**\n     * Raw rows before any derive pipeline transformations.\n     */\n    rowsAll: readonly TRow[];\n\n    /**\n     * Optional selection snapshot if the selection feature is registered.\n     * The shape depends on the selection feature implementation.\n     */\n    selection?: unknown;\n\n    /**\n     * Safely updates the raw rows by providing an updater function.\n     *\n     * @param updater - Function that receives current rows and returns updated rows\n     */\n    updateRows: (updater: (current: TRow[]) => TRow[]) => void;\n\n    /**\n     * Triggers a refresh of the list data.\n     *\n     * @returns Promise that resolves when refresh is complete\n     */\n    refresh: () => Promise<void>;\n\n    /**\n     * Exports the current state of the list.\n     *\n     * @returns The exported state object\n     */\n    exportState: () => unknown;\n\n    /**\n     * Registry of all registered feature APIs.\n     */\n    features: Record<string, unknown>;\n\n    /**\n     * Metadata about the list configuration.\n     */\n    meta: {\n        /**\n         * The property name used as unique identifier for rows.\n         */\n        idKey: string;\n\n        /**\n         * Optional field definitions or schema.\n         */\n        fields?: unknown;\n    };\n};\n\n/**\n * Defines a general action that can be triggered on the list.\n *\n * @public\n */\nexport type GeneralAction = {\n    /**\n     * Unique identifier for the action.\n     */\n    id: string;\n\n    /**\n     * Optional human-readable label for the action.\n     */\n    label?: string;\n\n    /**\n     * Optional predicate to determine if the action is currently enabled.\n     *\n     * @param ctx - Read-only context without updateRows capability\n     * @returns True if the action should be enabled, false otherwise\n     */\n    isEnabled?: (ctx: Omit<GeneralActionHandlerContext<any>, \"updateRows\">) => boolean;\n\n    /**\n     * Optional modal request factory. If defined, triggering the action will open a modal.\n     * The scope and actionId are automatically injected by the feature.\n     *\n     * @param ctx - Read-only context without updateRows capability\n     * @returns Modal request configuration with optional metadata\n     */\n    modal?: (ctx: Omit<GeneralActionHandlerContext<any>, \"updateRows\">) => {\n        /**\n         * Optional metadata to pass to the modal.\n         */\n        meta?: Record<string, unknown>;\n    };\n\n    /**\n     * The action handler function that executes the action logic.\n     *\n     * @param ctx - Full action context including updateRows capability\n     * @param payload - Optional payload data, typically from modal confirmation\n     * @returns Optional promise for async operations\n     */\n    handler: (ctx: GeneralActionHandlerContext<any>, payload?: unknown) => void | Promise<void>;\n};\n\n/**\n * Represents a general action that is pending modal confirmation.\n *\n * @internal\n */\ntype PendingGeneralAction = {\n    /**\n     * The ID of the action awaiting modal resolution.\n     */\n    actionId: string;\n};\n\n/**\n * State slice stored in the feature state for tracking pending actions.\n *\n * @internal\n */\ntype GeneralActionsSlice = {\n    /**\n     * The currently pending action awaiting modal confirmation, if any.\n     */\n    pending?: PendingGeneralAction;\n};\n\n/**\n * Public API exposed by the general actions feature.\n *\n * @public\n */\nexport type GeneralActionsApi = {\n    /**\n     * Retrieves all registered general actions.\n     *\n     * @returns Read-only array of all general actions\n     */\n    getActions: () => ReadonlyArray<GeneralAction>;\n\n    /**\n     * Triggers a general action by its ID.\n     *\n     * @param actionId - The unique identifier of the action to trigger\n     * @returns Promise that resolves when the action completes or modal opens\n     */\n    trigger: (actionId: string) => Promise<void>;\n};\n\n/**\n * Performs a runtime check to determine if the modals feature is registered and retrieves its API.\n *\n * @param ctx - The list feature context\n * @returns The modals API if available and valid, null otherwise\n * @internal\n */\nfunction getModalsApi(ctx: ListFeatureContext<any, any, any, any>) {\n    const api = (ctx.features as any)?.modals;\n    if (!api) return null;\n\n    const has =\n        typeof api.open === \"function\" &&\n        typeof api.onResolve === \"function\";\n\n    return has\n        ? (api as {\n            open: (d: ModalDescriptor<any>) => void;\n            onResolve: (l: (r: ModalResult<any>) => void) => () => void;\n        })\n        : null;\n}\n\n/**\n * Creates a general actions feature that enables triggering custom actions on the list.\n *\n * This feature allows defining actions that can be executed on the entire list,\n * with optional modal confirmation dialogs. Actions can access list state, modify rows,\n * and integrate with other features like selection.\n *\n * @public\n * @typeParam TRow - The row data type\n * @param options - Configuration options for the feature\n * @returns A list feature with UI slots and action trigger capabilities\n * @throws Error if actions array is not provided or if idKey is missing from context metadata\n *\n * @example\n * ```typescript\n * const feature = generalActionsFeature({\n *   actions: [\n *     {\n *       id: 'delete-all',\n *       label: 'Delete All',\n *       modal: () => ({ meta: { title: 'Confirm Delete' } }),\n *       handler: async (ctx) => {\n *         ctx.updateRows(() => []);\n *       }\n *     }\n *   ]\n * });\n * ```\n */\nexport function generalActionsFeature<TRow = any>(\n    options: { actions: Array<GeneralAction> }\n): ListFeatureWithUI<TRow, any, CoreListState<TRow>, unknown, GeneralActionsApi> {\n    if (!options?.actions) {\n        throw new Error(\"generalActionsFeature requires { actions }.\");\n    }\n\n    return {\n        id: FEATURE_ID,\n\n        ui: {\n            slots: [\"Toolbar\"],\n            requiredHandlers: [\"trigger\"],\n        },\n\n        create(ctx) {\n            const idKey = ctx.meta?.idKey;\n            if (!idKey) {\n                throw new Error(\"generalActionsFeature requires ctx.meta.idKey (string).\");\n            }\n\n            const modals = getModalsApi(ctx);\n\n            const readSlice = (): GeneralActionsSlice => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                return getFeatureSlice<GeneralActionsSlice>(state, FEATURE_ID, () => ({\n                    pending: undefined,\n                }));\n            };\n\n            const writeSlice = (slice: GeneralActionsSlice) => {\n                ctx.setState((prev: CoreListState<TRow>) => setFeatureSlice(prev, FEATURE_ID, slice));\n            };\n\n            const buildBaseCtx = (): Omit<GeneralActionHandlerContext<TRow>, \"updateRows\"> => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n\n                const selectionApi = (ctx.features as any)?.selection;\n                const selection =\n                    selectionApi && typeof selectionApi.getSelection === \"function\"\n                        ? selectionApi.getSelection()\n                        : undefined;\n\n                return {\n                    rowsVisible: state.rows ?? [],\n                    rowsAll: state.rawRows ?? [],\n                    selection,\n                    refresh: ctx.refresh,\n                    exportState: ctx.exportState,\n                    features: ctx.features,\n                    meta: {\n                        idKey,\n                        fields: ctx.meta?.fields,\n                    },\n                };\n            };\n\n            const buildFullCtx = (): GeneralActionHandlerContext<TRow> => {\n                const base = buildBaseCtx();\n\n                const updateRows = (updater: (current: TRow[]) => TRow[]) => {\n                    ctx.setState((prev: CoreListState<TRow>) => ({\n                        ...prev,\n                        rawRows: updater(prev.rawRows),\n                    }));\n                };\n\n                return {...base, updateRows};\n            };\n\n            const runAction = async (action: GeneralAction, payload?: unknown) => {\n                const base = buildBaseCtx();\n\n                if (action.isEnabled && action.isEnabled(base) === false) {\n                    return;\n                }\n\n                if (action.modal) {\n                    if (!modals) {\n                        throw new Error(\n                            `General action '${action.id}' requested a modal, but modals feature is not registered.`\n                        );\n                    }\n\n                    const request = action.modal(base);\n                    modals.open({\n                        scope: \"general-action\",\n                        actionId: action.id,\n                        meta: request?.meta,\n                    });\n\n                    writeSlice({pending: {actionId: action.id}});\n                    return;\n                }\n\n                await action.handler(buildFullCtx(), payload);\n            };\n\n            // Listen for modal confirms related to general actions\n            let unsubscribe: null | (() => void) = null;\n            if (modals) {\n                unsubscribe = modals.onResolve(async (result) => {\n                    if (result.status !== \"confirmed\") return;\n                    if (result.descriptor.scope !== \"general-action\") return;\n\n                    const pending = readSlice().pending;\n                    if (!pending) return;\n\n                    if (result.descriptor.actionId !== pending.actionId) return;\n\n                    writeSlice({pending: undefined});\n\n                    const action = options.actions.find((a) => a.id === pending.actionId);\n                    if (!action) return;\n\n                    await action.handler(buildFullCtx(), (result as any).payload);\n                });\n            }\n\n            (ctx.features as any).__generalActionsUnsub = unsubscribe;\n\n            const api: GeneralActionsApi = {\n                getActions: () => options.actions,\n\n                trigger: async (actionId) => {\n                    const action = options.actions.find((a) => a.id === actionId);\n                    if (!action) return;\n                    await runAction(action);\n                },\n            };\n\n            return api;\n        },\n\n        onDestroy(ctx) {\n            const unsub = (ctx.features as any).__generalActionsUnsub;\n            if (typeof unsub === \"function\") {\n                try {\n                    unsub();\n                } catch {\n                }\n            }\n            delete (ctx.features as any).__generalActionsUnsub;\n        },\n    };\n}\n","import type { ModalDescriptor, ModalResult } from \"../modals\";\nimport {ListFeatureContext} from \"../../core/context/listFeatureContext\";\nimport {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\nconst FEATURE_ID = \"rowActions\";\n\n/**\n * Represents a modal request configuration for row actions.\n *\n * @public\n */\nexport type ModalRequest = {\n    /**\n     * Optional metadata to be passed to the modal.\n     */\n    meta?: Record<string, unknown>;\n};\n\n/**\n * The handler context passed to a row action when it is executed.\n * Provides access to the current row, visible and raw row data, selection state,\n * state mutation methods, and feature APIs.\n *\n * @typeParam TRow - The type of row data objects\n * @typeParam TRowId - The type of row identifier values\n *\n * @public\n */\nexport type RowActionHandlerContext<TRow = any, TRowId = any> = {\n    /**\n     * The current row data object being acted upon.\n     */\n    row: TRow;\n\n    /**\n     * The unique identifier of the current row.\n     */\n    rowId: TRowId;\n\n    /**\n     * The zero-based index of the current row within the visible rows array.\n     */\n    rowIndex: number;\n\n    /**\n     * All visible rows after filtering, sorting, and pagination have been applied.\n     */\n    rowsVisible: readonly TRow[];\n\n    /**\n     * All raw rows before any derive pipeline transformations have been applied.\n     */\n    rowsAll: readonly TRow[];\n\n    /**\n     * Optional selection feature snapshot, populated if the selection plugin is registered.\n     */\n    selection?: unknown;\n\n    /**\n     * Safely updates the raw rows state using an updater function.\n     *\n     * @param updater - A function that receives the current raw rows array and returns the updated array\n     */\n    updateRows: (updater: (current: TRow[]) => TRow[]) => void;\n\n    /**\n     * Triggers a refresh of the list data.\n     *\n     * @returns A promise that resolves when the refresh is complete\n     */\n    refresh: () => Promise<void>;\n\n    /**\n     * Exports the current list state.\n     *\n     * @returns The exported state object\n     */\n    exportState: () => unknown;\n\n    /**\n     * Namespace containing all registered feature APIs.\n     */\n    features: Record<string, unknown>;\n\n    /**\n     * Metadata about the list configuration.\n     */\n    meta: {\n        /**\n         * The property name used as the unique identifier for rows.\n         */\n        idKey: string;\n\n        /**\n         * Optional field definitions or metadata.\n         */\n        fields?: unknown;\n    };\n};\n\n/**\n * Defines a row action that can be executed on individual rows within the list.\n * Actions can optionally present a modal for user confirmation before execution.\n *\n * @typeParam TRow - The type of row data objects\n * @typeParam TRowId - The type of row identifier values\n *\n * @public\n */\nexport type RowAction<TRow = any, TRowId = any> = {\n    /**\n     * Unique identifier for the row action.\n     */\n    id: string;\n\n    /**\n     * Optional human-readable label for the action.\n     */\n    label?: string;\n\n    /**\n     * Optional availability guard that determines if the action should be enabled for a given row.\n     *\n     * @param ctx - The row action context without the updateRows method\n     * @returns `true` if the action should be enabled, `false` otherwise\n     */\n    isEnabled?: (ctx: Omit<RowActionHandlerContext<TRow, TRowId>, \"updateRows\">) => boolean;\n\n    /**\n     * Optional modal descriptor factory. If provided, the action will open a modal for user confirmation\n     * before executing the handler. The modal's confirmation payload will be passed to the handler.\n     *\n     * @param ctx - The row action context without the updateRows method\n     * @returns A modal request configuration\n     */\n    modal?: (\n        ctx: Omit<RowActionHandlerContext<TRow, TRowId>, \"updateRows\">\n    ) => ModalRequest;\n\n    /**\n     * The actual action handler that performs the row action logic.\n     * If a modal is configured, this handler runs only after user confirmation.\n     *\n     * @param ctx - The complete row action handler context\n     * @param payload - Optional payload data, typically from modal confirmation\n     * @returns A promise if the action is asynchronous, or void for synchronous actions\n     */\n    handler: (ctx: RowActionHandlerContext<TRow, TRowId>, payload?: unknown) => void | Promise<void>;\n};\n\ntype PendingRowAction<TRowId = any> = {\n    actionId: string;\n    rowId: TRowId;\n};\n\ntype RowActionsSlice<TRowId = any> = {\n    pending?: PendingRowAction<TRowId>;\n};\n\n/**\n * Public API for the row actions feature, providing methods to retrieve and trigger row actions.\n *\n * @typeParam TRow - The type of row data objects\n * @typeParam TRowId - The type of row identifier values\n *\n * @public\n */\nexport type RowActionsApi<TRow = any, TRowId = any> = {\n    /**\n     * Retrieves all registered row actions.\n     *\n     * @returns A read-only array of row actions\n     */\n    getActions: () => ReadonlyArray<RowAction<TRow, TRowId>>;\n\n    /**\n     * Triggers a row action using a visible row index.\n     *\n     * @param actionId - The unique identifier of the action to trigger\n     * @param rowIndex - The zero-based index of the row within the visible rows array\n     * @returns A promise that resolves when the action completes\n     */\n    triggerAt: (actionId: string, rowIndex: number) => Promise<void>;\n\n    /**\n     * Triggers a row action using a row identifier.\n     * The row index will be resolved against the visible rows array.\n     *\n     * @param actionId - The unique identifier of the action to trigger\n     * @param rowId - The unique identifier of the target row\n     * @returns A promise that resolves when the action completes\n     */\n    triggerById: (actionId: string, rowId: TRowId) => Promise<void>;\n};\n\n/**\n * Configuration options for the row actions feature.\n *\n * @typeParam TRow - The type of row data objects\n * @typeParam TRowId - The type of row identifier values\n *\n * @public\n */\nexport type RowActionsFeatureOptions<TRow = any, TRowId = any> = {\n    /**\n     * Array of row actions to be registered with the feature.\n     */\n    actions: Array<RowAction<TRow, TRowId>>;\n};\n\n/**\n * Performs a runtime check to determine if the modals feature is registered and provides its API.\n *\n * @param ctx - The list feature context\n * @returns The modals API object if available and valid, or `null` otherwise\n *\n * @internal\n */\nfunction getModalsApi(ctx: ListFeatureContext<any, any, any, any>) {\n    const api = (ctx.features as any)?.modals;\n    if (!api) return null;\n\n    const has =\n        typeof api.open === \"function\" &&\n        typeof api.onResolve === \"function\";\n\n    return has ? (api as {\n        open: (d: ModalDescriptor<any>) => void;\n        onResolve: (l: (r: ModalResult<any>) => void) => () => void;\n    }) : null;\n}\n\n/**\n * Creates a row actions feature that enables defining and executing actions on individual rows.\n * Row actions can optionally integrate with the modals feature for user confirmation dialogs.\n * The feature provides methods to trigger actions by row index or row ID, and automatically\n * manages action availability, modal workflows, and state updates.\n *\n * @remarks\n * This feature requires:\n * - `ctx.meta.idKey` to be defined as a string property name for row identification\n * - The modals feature to be registered if any actions use the `modal` option\n *\n * The feature automatically subscribes to modal resolution events and cleans up subscriptions\n * during destruction.\n *\n * @typeParam TRow - The type of row data objects\n * @typeParam TRowId - The type of row identifier values\n *\n * @param options - Configuration options including the array of row actions\n * @returns A list feature with UI integration and row actions API\n *\n * @throws Error if options.actions is not provided\n * @throws Error if ctx.meta.idKey is not defined during feature creation\n * @throws Error if an action requests a modal but the modals feature is not registered\n *\n * @public\n */\nexport function rowActionsFeature<TRow = any, TRowId = any>(\n    options: RowActionsFeatureOptions<TRow, TRowId>\n): ListFeatureWithUI<TRow, TRowId, CoreListState<TRow>, unknown, RowActionsApi<TRow, TRowId>> {\n    if (!options?.actions) {\n        throw new Error(\"rowActionsFeature requires { actions }.\");\n    }\n\n    return {\n        id: FEATURE_ID,\n\n        ui: {\n            slots: [\"Table\"],\n            requiredHandlers: [\"triggerAt\", \"triggerById\"],\n        },\n\n        create(ctx) {\n            const idKey = ctx.meta?.idKey;\n            if (!idKey) {\n                throw new Error(\"rowActionsFeature requires ctx.meta.idKey (string).\");\n            }\n\n            const modals = getModalsApi(ctx);\n\n            const readSlice = (): RowActionsSlice<TRowId> => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                return getFeatureSlice<RowActionsSlice<TRowId>>(state, FEATURE_ID, () => ({\n                    pending: undefined,\n                }));\n            };\n\n            const writeSlice = (slice: RowActionsSlice<TRowId>) => {\n                ctx.setState((prev: CoreListState<TRow>) => setFeatureSlice(prev, FEATURE_ID, slice));\n            };\n\n            const buildBaseCtx = (row: TRow, rowIndex: number): Omit<RowActionHandlerContext<TRow, TRowId>, \"updateRows\"> => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                const rowId = (row as any)[idKey] as TRowId;\n\n                // optional selection snapshot if selection feature exists\n                const selectionApi = (ctx.features as any)?.selection;\n                const selection =\n                    selectionApi && typeof selectionApi.getSelection === \"function\"\n                        ? selectionApi.getSelection()\n                        : undefined;\n\n                return {\n                    row,\n                    rowId,\n                    rowIndex,\n                    rowsVisible: state.rows ?? [],\n                    rowsAll: state.rawRows ?? [],\n                    selection,\n                    refresh: ctx.refresh,\n                    exportState: ctx.exportState,\n                    features: ctx.features,\n                    meta: {\n                        idKey,\n                        fields: ctx.meta?.fields,\n                    },\n                };\n            };\n\n            const buildFullCtx = (row: TRow, rowIndex: number): RowActionHandlerContext<TRow, TRowId> => {\n                const base = buildBaseCtx(row, rowIndex);\n\n                const updateRows = (updater: (current: TRow[]) => TRow[]) => {\n                    ctx.setState((prev: CoreListState<TRow>) => ({\n                        ...prev,\n                        rawRows: updater(prev.rawRows),\n                    }));\n                };\n\n                return { ...base, updateRows };\n            };\n\n            const findVisibleRowById = (rowId: TRowId): { row: TRow; rowIndex: number } | null => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                const rows = state.rows ?? [];\n                const idx = rows.findIndex((r) => ((r as any)[idKey] as TRowId) === rowId);\n                if (idx < 0) return null;\n                return { row: rows[idx] as TRow, rowIndex: idx };\n            };\n\n            const runAction = async (action: RowAction<TRow, TRowId>, row: TRow, rowIndex: number, payload?: unknown) => {\n                const base = buildBaseCtx(row, rowIndex);\n\n                if (action.isEnabled && action.isEnabled(base) === false) {\n                    return;\n                }\n\n                // modal flow\n                if (action.modal) {\n                    if (!modals) {\n                        throw new Error(\n                            `Row action '${action.id}' requested a modal, but modals feature is not registered.`\n                        );\n                    }\n\n                    const request = action.modal(base);\n                    modals.open({\n                        scope: \"row-action\",\n                        actionId: action.id,\n                        rowId: base.rowId,\n                        meta: request.meta,\n                    });\n\n                    writeSlice({pending: {actionId: action.id, rowId: base.rowId}});\n                    return;\n                }\n\n                await action.handler(buildFullCtx(row, rowIndex), payload);\n            };\n\n            let unsubscribe: null | (() => void) = null;\n            if (modals) {\n                unsubscribe = modals.onResolve(async (result) => {\n                    if (result.status !== \"confirmed\") return;\n                    if (result.descriptor.scope !== \"row-action\") return;\n\n                    const pending = readSlice().pending;\n                    if (!pending) return;\n\n                    if (result.descriptor.actionId !== pending.actionId) return;\n                    if ((result.descriptor.rowId as any) !== (pending.rowId as any)) return;\n\n                    writeSlice({ pending: undefined });\n\n                    const action = options.actions.find((a) => a.id === pending.actionId);\n                    if (!action) return;\n\n                    const resolved = findVisibleRowById(pending.rowId);\n                    if (!resolved) return;\n\n                    await action.handler(buildFullCtx(resolved.row, resolved.rowIndex), (result as any).payload);\n                });\n            }\n\n            (ctx.features as any).__rowActionsUnsub = unsubscribe;\n\n            const api: RowActionsApi<TRow, TRowId> = {\n                getActions: () => options.actions,\n\n                triggerAt: async (actionId, rowIndex) => {\n                    const action = options.actions.find((a) => a.id === actionId);\n                    if (!action) return;\n\n                    const state = ctx.stateRef.current as CoreListState<TRow>;\n                    const row = (state.rows ?? [])[rowIndex] as TRow | undefined;\n                    if (!row) return;\n\n                    await runAction(action, row, rowIndex);\n                },\n\n                triggerById: async (actionId, rowId) => {\n                    const action = options.actions.find((a) => a.id === actionId);\n                    if (!action) return;\n\n                    const resolved = findVisibleRowById(rowId);\n                    if (!resolved) return;\n\n                    await runAction(action, resolved.row, resolved.rowIndex);\n                },\n            };\n\n            return api;\n        },\n\n        onDestroy(ctx) {\n            const unsub = (ctx.features as any).__rowActionsUnsub;\n            if (typeof unsub === \"function\") {\n                try { unsub(); } catch {}\n            }\n            delete (ctx.features as any).__rowActionsUnsub;\n        },\n    };\n}\n","import {ListFeatureContext} from \"../../core/context/listFeatureContext\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\n/**\n * Represents the filters value that can be of any type.\n *\n * @remarks\n * This type is intentionally kept as unknown to allow maximum flexibility in filter implementations.\n * Consumers should cast this to their specific filter structure.\n *\n * @public\n */\nexport type FiltersValue = unknown;\n\n/**\n * Function type for applying filters to a collection of rows.\n *\n * @remarks\n * This function defines the filtering strategy and is called during the derive phase\n * to filter the rows based on the current filter values. The implementation is\n * completely custom and library-agnostic.\n *\n * @typeParam TRow - The type of row data being filtered\n *\n * @param rows - The readonly array of rows to be filtered\n * @param filters - The current filter values to apply\n * @param ctx - The list feature context providing access to state and utilities\n *\n * @returns A readonly array of filtered rows\n *\n * @public\n */\nexport type FilteringApplyFn<TRow = any> = (\n    rows: readonly TRow[],\n    filters: FiltersValue,\n    ctx: ListFeatureContext<TRow, any, CoreListState<TRow>, unknown>\n) => readonly TRow[];\n\n/**\n * Configuration options for the filtering feature.\n *\n * @remarks\n * These options define how the filtering feature behaves, including the filtering\n * logic and initial filter state. The library remains agnostic to the actual\n * filtering implementation.\n *\n * @typeParam TRow - The type of row data being filtered\n *\n * @public\n */\nexport type FilteringFeatureOptions<TRow = any> = {\n    /**\n     * The filtering strategy function that applies filters to rows.\n     *\n     * @remarks\n     * This is a required function that implements your custom filtering logic.\n     * The library does not impose any specific filtering algorithm.\n     */\n    apply: FilteringApplyFn<TRow>;\n\n    /**\n     * The initial filter values to use when the feature is first created.\n     *\n     * @remarks\n     * If not provided, defaults to an empty object.\n     */\n    initial?: FiltersValue;\n};\n\n/**\n * Internal state slice for the filtering feature.\n *\n * @remarks\n * This type represents the portion of the feature state that is managed by\n * the filtering feature. It is stored in the global list state under the\n * feature's ID.\n *\n * @internal\n */\ntype FilteringSlice = {\n    /**\n     * The current filter values.\n     */\n    value: FiltersValue;\n};\n\n/**\n * API interface for managing filters in a list.\n *\n * @remarks\n * This interface provides methods to get, set, and clear filter values.\n * It is returned by the filtering feature and can be used by UI components\n * or other features to interact with the filtering state.\n *\n * @public\n */\nexport type FilteringApi = {\n    /**\n     * Retrieves the current filter values.\n     *\n     * @returns The current filters value\n     */\n    getFilters: () => FiltersValue;\n\n    /**\n     * Sets new filter values.\n     *\n     * @remarks\n     * Can accept either a direct value or a function that receives the previous\n     * filters and returns the new filters. This allows for both direct updates\n     * and updates based on the current state.\n     *\n     * @param next - The new filters value or a function to compute it from the previous value\n     */\n    setFilters: (next: FiltersValue | ((prev: FiltersValue) => FiltersValue)) => void;\n\n    /**\n     * Resets the filters to their initial values.\n     *\n     * @remarks\n     * This will set the filters back to the value specified in the `initial` option,\n     * or to an empty object if no initial value was provided.\n     */\n    clearFilters: () => void;\n};\n\nconst FEATURE_ID = \"filters\";\n\n/**\n * Creates a filtering feature for a list.\n *\n * @remarks\n * This function creates a list feature that adds filtering capabilities to a list.\n * It provides an API for managing filter state and automatically applies filters\n * during the derive phase. The feature includes UI slots for filter panels and\n * requires setFilters handler to be implemented.\n *\n * The filtering logic is completely customizable through the `apply` function,\n * allowing you to implement any filtering strategy that fits your needs.\n *\n * @typeParam TRow - The type of row data being filtered\n *\n * @param options - Configuration options for the filtering feature\n *\n * @returns A list feature with UI support that provides filtering capabilities\n *\n * @throws Error if the `apply` function is not provided in options\n *\n * @example\n * ```typescript\n * const filtering = filteringFeature({\n *   apply: (rows, filters) => rows.filter(row => row.name.includes(filters.search)),\n *   initial: { search: '' }\n * });\n * ```\n *\n * @public\n */\nexport function filteringFeature<TRow = any>(\n    options: FilteringFeatureOptions<TRow>\n): ListFeatureWithUI<TRow, any, CoreListState<TRow>, unknown, FilteringApi> {\n    if (!options?.apply) {\n        throw new Error(\"filteringFeature requires an 'apply' function.\");\n    }\n\n    return {\n        id: FEATURE_ID,\n\n        ui: {\n            slots: [\"FiltersPanel\"],\n            requiredHandlers: [\"setFilters\"],\n        },\n\n        create(ctx) {\n            const readSlice = (): FilteringSlice => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                return getFeatureSlice<FilteringSlice>(state, FEATURE_ID, () => ({\n                    value: options.initial ?? {},\n                }));\n            };\n\n            const writeSlice = (slice: FilteringSlice) => {\n                ctx.setState((prev: CoreListState<TRow>) => setFeatureSlice(prev, FEATURE_ID, slice));\n            };\n\n            const api: FilteringApi = {\n                getFilters: () => readSlice().value,\n\n                setFilters: (next) => {\n                    writeSlice({\n                        value:\n                            typeof next === \"function\"\n                                ? (next as (p: FiltersValue) => FiltersValue)(readSlice().value)\n                                : next,\n                    });\n                },\n\n                clearFilters: () => {\n                    writeSlice({value: options.initial ?? {}});\n                },\n            };\n\n            return api;\n        },\n\n        derive(rows, ctx) {\n            const state = ctx.stateRef.current as CoreListState<TRow>;\n            const slice = getFeatureSlice<FilteringSlice>(state, FEATURE_ID, () => ({\n                value: options.initial ?? {},\n            }));\n\n            return options.apply(rows, slice.value, ctx as any);\n        },\n    };\n}\n","import {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\nconst FEATURE_ID = \"modals\";\n\n/**\n * Defines the context in which a modal was opened.\n *\n * @remarks\n * This type categorizes modal origins to maintain generic modal implementations\n * while still supporting specific action contexts. The scope helps other features\n * (like actions) understand how to handle modal results.\n *\n * - `row-action`: Modal opened from an action on a specific row\n * - `general-action`: Modal opened from a general action not tied to a specific row\n * - `custom`: Modal opened from custom application logic\n *\n * @public\n */\nexport type ModalScope = \"row-action\" | \"general-action\" | \"custom\";\n\n/**\n * Describes a modal's configuration and context.\n *\n * @remarks\n * This descriptor contains all information needed to display and track a modal.\n * It intentionally keeps the modal system generic by using a flexible metadata\n * structure while providing optional correlation identifiers.\n *\n * @typeParam TRowId - The type of row identifier used in the list\n *\n * @public\n */\nexport type ModalDescriptor<TRowId = any> = {\n  /**\n   * The context in which the modal was opened.\n   */\n  scope: ModalScope;\n\n  /**\n   * Optional identifier for the action that triggered the modal.\n   *\n   * @remarks\n   * This allows features like the actions plugin to correlate modal results\n   * back to the originating action.\n   */\n  actionId?: string;\n\n  /**\n   * Optional identifier for the row associated with the modal.\n   *\n   * @remarks\n   * Relevant when scope is \"row-action\", allowing the modal to reference\n   * the specific row being acted upon.\n   */\n  rowId?: TRowId;\n\n  /**\n   * Flexible metadata for the modal implementation.\n   *\n   * @remarks\n   * Consumers can provide any data needed by their ModalOutlet UI component,\n   * such as title, message, form schema, validation rules, etc. The structure\n   * is intentionally open-ended to support various modal types.\n   */\n  meta?: Record<string, unknown>;\n};\n\n/**\n * Represents the result of a modal interaction.\n *\n * @remarks\n * This discriminated union type captures the outcome of a modal, either confirmed\n * with optional payload data or cancelled. The descriptor is included in both cases\n * to maintain context about which modal was resolved.\n *\n * @typeParam TRowId - The type of row identifier used in the list\n *\n * @public\n */\nexport type ModalResult<TRowId = any> =\n    | {\n  /**\n   * Indicates the modal was confirmed by the user.\n   */\n  status: \"confirmed\";\n  /**\n   * The original modal descriptor that was resolved.\n   */\n  descriptor: ModalDescriptor<TRowId>;\n  /**\n   * Optional data returned from the modal (e.g., form values, user selections).\n   */\n  payload?: unknown;\n}\n    | {\n  /**\n   * Indicates the modal was cancelled by the user.\n   */\n  status: \"cancelled\";\n  /**\n   * The original modal descriptor that was resolved.\n   */\n  descriptor: ModalDescriptor<TRowId>;\n    };\n\n/**\n * Internal state slice for the modals feature.\n *\n * @remarks\n * This type represents the portion of the feature state that is managed by\n * the modals feature. It is stored in the global list state under the\n * feature's ID and tracks the currently active modal, resolution history,\n * and state changes.\n *\n * @typeParam TRowId - The type of row identifier used in the list\n *\n * @internal\n */\ntype ModalsSlice<TRowId = any> = {\n  /**\n   * The currently active modal descriptor, if any.\n   *\n   * @remarks\n   * When undefined, no modal is currently open. Only one modal can be\n   * active at a time.\n   */\n  active?: ModalDescriptor<TRowId>;\n\n  /**\n   * Incrementing counter to detect state changes.\n   *\n   * @remarks\n   * This version number increases with each modal operation (open, close, confirm, cancel)\n   * making it easy to detect resolution edges and state transitions in UI components.\n   */\n  version: number;\n\n  /**\n   * The most recent modal resolution result.\n   *\n   * @remarks\n   * This stores the last confirmed or cancelled result and is cleared when\n   * a new modal opens. Useful for debugging or implementing undo functionality.\n   */\n  lastResult?: ModalResult<TRowId>;\n};\n\n/**\n * API interface for managing modals in a list.\n *\n * @remarks\n * This interface provides methods to open, close, and resolve modals, as well as\n * subscribe to resolution events. It is returned by the modals feature and can be\n * used by UI components or other features to interact with modal state.\n *\n * @typeParam TRowId - The type of row identifier used in the list\n *\n * @public\n */\nexport type ModalsApi<TRowId = any> = {\n  /**\n   * Retrieves the currently active modal descriptor.\n   *\n   * @returns The active modal descriptor, or undefined if no modal is open\n   */\n  getActive: () => ModalDescriptor<TRowId> | undefined;\n\n  /**\n   * Opens a modal with the specified descriptor.\n   *\n   * @remarks\n   * By default, this replaces any currently open modal. If strictSingle mode\n   * is enabled in feature options, attempting to open a modal while one is\n   * active will throw an error.\n   *\n   * @param descriptor - The modal descriptor containing configuration and context\n   *\n   * @throws Error if strictSingle is enabled and a modal is already active\n   */\n  open: (descriptor: ModalDescriptor<TRowId>) => void;\n\n  /**\n   * Closes the current modal without resolving it.\n   *\n   * @remarks\n   * This is rarely needed but useful for edge cases like navigation away from\n   * the list or programmatic dismissal. Does nothing if no modal is active.\n   * Subscribers will not be notified as this is not a resolution.\n   */\n  close: () => void;\n\n  /**\n   * Resolves the current modal as confirmed with optional payload.\n   *\n   * @remarks\n   * This closes the modal, stores the confirmation result, and notifies all\n   * subscribers. Does nothing if no modal is active.\n   *\n   * @param payload - Optional data to include with the confirmation result\n   */\n  confirm: (payload?: unknown) => void;\n\n  /**\n   * Resolves the current modal as cancelled.\n   *\n   * @remarks\n   * This closes the modal, stores the cancellation result, and notifies all\n   * subscribers. Does nothing if no modal is active.\n   */\n  cancel: () => void;\n\n  /**\n   * Subscribes to modal resolution events.\n   *\n   * @remarks\n   * The listener will be called whenever a modal is confirmed or cancelled\n   * (but not when closed without resolution). This is useful for features\n   * like actions that need to respond to modal outcomes.\n   *\n   * @param listener - Function to call when a modal is resolved\n   *\n   * @returns A function that unsubscribes the listener when called\n   */\n  onResolve: (listener: (result: ModalResult<TRowId>) => void) => () => void;\n};\n\n/**\n * Configuration options for the modals feature.\n *\n * @remarks\n * These options control the behavior of the modals feature, including\n * how multiple modal requests are handled.\n *\n * @public\n */\nexport type ModalsFeatureOptions = {\n  /**\n   * Enforces strict single-modal behavior.\n   *\n   * @remarks\n   * When enabled, attempting to open a modal while one is already active\n   * will throw an error instead of replacing the existing modal. This can\n   * help catch programming errors where multiple modals are unintentionally\n   * triggered.\n   *\n   * @defaultValue false - By default, opening a new modal replaces any active modal\n   */\n  strictSingle?: boolean;\n};\n\n/**\n * Creates a modals feature for a list.\n *\n * @remarks\n * This function creates a list feature that adds modal management capabilities to a list.\n * It provides an API for opening, closing, and resolving modals, as well as subscribing\n * to modal resolution events. The feature includes UI slots for modal outlets and\n * requires specific handlers to be implemented by the UI layer.\n *\n * The modal system is intentionally generic, using flexible descriptors and metadata\n * to support various modal types while maintaining integration with other features\n * like actions through correlation identifiers.\n *\n * Only one modal can be active at a time, though this behavior can be made stricter\n * with the strictSingle option.\n *\n * @typeParam TRow - The type of row data in the list\n * @typeParam TRowId - The type of row identifier used in the list\n *\n * @param options - Configuration options for the modals feature\n *\n * @returns A list feature with UI support that provides modal management capabilities\n *\n * @example\n * ```typescript\n * const modals = modalsFeature({\n *   strictSingle: true\n * });\n *\n * // Later in your code\n * modals.open({\n *   scope: 'row-action',\n *   actionId: 'delete',\n *   rowId: '123',\n *   meta: {\n *     title: 'Confirm Delete',\n *     message: 'Are you sure you want to delete this item?'\n *   }\n * });\n *\n * modals.onResolve((result) => {\n *   if (result.status === 'confirmed') {\n *     // Handle confirmation\n *   }\n * });\n * ```\n *\n * @public\n */\nexport function modalsFeature<TRow = any, TRowId = any>(\n  options: ModalsFeatureOptions = {}\n): ListFeatureWithUI<TRow, TRowId, CoreListState<TRow>, unknown, ModalsApi<TRowId>> {\n  const strictSingle = options.strictSingle ?? false;\n\n  return {\n    id: FEATURE_ID,\n\n    ui: {\n      slots: [\"ModalOutlet\"],\n      requiredHandlers: [\"getActive\", \"open\", \"confirm\", \"cancel\", \"close\"],\n    },\n\n    create(ctx) {\n      const listeners = new Set<(result: ModalResult<TRowId>) => void>();\n\n      const readSlice = (): ModalsSlice<TRowId> => {\n        const state = ctx.stateRef.current as CoreListState<TRow>;\n        return getFeatureSlice<ModalsSlice<TRowId>>(state, FEATURE_ID, () => ({\n          active: undefined,\n          version: 0,\n          lastResult: undefined,\n        }));\n      };\n\n      const writeSlice = (slice: ModalsSlice<TRowId>) => {\n        ctx.setState((prev: CoreListState<TRow>) => setFeatureSlice(prev, FEATURE_ID, slice));\n      };\n\n      const emit = (result: ModalResult<TRowId>) => {\n        for (const l of listeners) {\n          try {\n            l(result);\n          } catch {\n            // swallow to keep other listeners alive\n          }\n        }\n      };\n\n      const api: ModalsApi<TRowId> = {\n        getActive: () => readSlice().active,\n\n        open: (descriptor) => {\n          const s = readSlice();\n          if (strictSingle && s.active) {\n            throw new Error(\"A modal is already active. Close it before opening another.\");\n          }\n          writeSlice({\n            active: descriptor,\n            version: s.version + 1,\n            lastResult: undefined,\n          });\n        },\n\n        close: () => {\n          const s = readSlice();\n          if (!s.active) return;\n          writeSlice({\n            ...s,\n            active: undefined,\n            version: s.version + 1,\n          });\n        },\n\n        confirm: (payload) => {\n          const s = readSlice();\n          if (!s.active) return;\n\n          const result: ModalResult<TRowId> = {\n            status: \"confirmed\",\n            descriptor: s.active,\n            payload,\n          };\n\n          writeSlice({\n            active: undefined,\n            version: s.version + 1,\n            lastResult: result,\n          });\n\n          emit(result);\n        },\n\n        cancel: () => {\n          const s = readSlice();\n          if (!s.active) return;\n\n          const result: ModalResult<TRowId> = {\n            status: \"cancelled\",\n            descriptor: s.active,\n          };\n\n          writeSlice({\n            active: undefined,\n            version: s.version + 1,\n            lastResult: result,\n          });\n\n          emit(result);\n        },\n\n        onResolve: (listener) => {\n          listeners.add(listener);\n          return () => listeners.delete(listener);\n        },\n      };\n\n      return api;\n    },\n  };\n}\n","import {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\nconst FEATURE_ID = \"pagination\";\n\n/**\n * Internal state slice for the pagination feature.\n *\n * @remarks\n * This type represents the portion of the feature state that is managed by\n * the pagination feature. It is stored in the global list state under the\n * feature's ID and contains all pagination-related metadata.\n *\n * @public\n */\nexport type PaginationSlice = {\n    /**\n     * The current zero-based page index.\n     *\n     * @remarks\n     * This value is automatically constrained to be within valid bounds (0 to totalPages - 1).\n     */\n    pageIndex: number;\n\n    /**\n     * The number of items to display per page.\n     *\n     * @remarks\n     * This value must be at least 1 and is used to calculate the total number of pages.\n     */\n    pageSize: number;\n\n    /**\n     * The total number of items across all pages.\n     *\n     * @remarks\n     * This value is automatically calculated based on the number of rows after filtering and sorting.\n     */\n    totalItems: number;\n\n    /**\n     * The total number of pages based on the page size and total items.\n     *\n     * @remarks\n     * This value is automatically calculated as Math.ceil(totalItems / pageSize) with a minimum of 1.\n     */\n    totalPages: number;\n};\n\n/**\n * API interface for managing pagination in a list.\n *\n * @remarks\n * This interface provides methods to get and update pagination state.\n * It is returned by the pagination feature and can be used by UI components\n * or other features to interact with the pagination state. The feature\n * automatically handles page bounds validation and recalculation.\n *\n * @public\n */\nexport type PaginationApi = {\n    /**\n     * Retrieves the current pagination state.\n     *\n     * @returns The current pagination slice containing page index, page size, total items, and total pages\n     */\n    getPagination: () => PaginationSlice;\n\n    /**\n     * Sets the current page index.\n     *\n     * @remarks\n     * The page index is automatically constrained to valid bounds (0 to totalPages - 1).\n     * If the provided value is out of bounds, it will be clamped to the nearest valid value.\n     *\n     * @param pageIndex - The zero-based page index to navigate to\n     */\n    setPageIndex: (pageIndex: number) => void;\n\n    /**\n     * Sets the number of items per page.\n     *\n     * @remarks\n     * When the page size changes, the page index is automatically reset to 0.\n     * The page size is constrained to be at least 1.\n     *\n     * @param pageSize - The number of items to display per page (minimum 1)\n     */\n    setPageSize: (pageSize: number) => void;\n\n    /**\n     * Resets pagination to its initial state.\n     *\n     * @remarks\n     * This will restore the page index and page size to their initial values\n     * specified in the feature options, and reset totalItems and totalPages to 0.\n     */\n    reset: () => void;\n};\n\n/**\n * Configuration options for the pagination feature.\n *\n * @remarks\n * These options define the initial pagination state when the feature is created.\n * Both options are optional and have sensible defaults.\n *\n * @public\n */\nexport type PaginationFeatureOptions = {\n    /**\n     * The initial zero-based page index to display.\n     *\n     * @remarks\n     * If not provided, defaults to 0 (the first page).\n     *\n     * @defaultValue 0\n     */\n    initialPageIndex?: number;\n\n    /**\n     * The initial number of items to display per page.\n     *\n     * @remarks\n     * If not provided, defaults to 25 items per page.\n     *\n     * @defaultValue 25\n     */\n    initialPageSize?: number;\n};\n\nconst DEFAULT_PAGE_SIZE = 25;\n\n/**\n * Creates a pagination feature for a list.\n *\n * @remarks\n * This function creates a list feature that adds pagination capabilities to a list.\n * It provides an API for managing pagination state and automatically slices the\n * rows during the derive phase to show only the current page. The feature includes\n * UI slots for pagination controls and requires setPageIndex and setPageSize handlers\n * to be implemented.\n *\n * The pagination feature should typically be ordered after filters and sorting\n * to ensure proper calculation of total items and pages based on the filtered\n * and sorted dataset.\n *\n * The feature automatically:\n * - Calculates total pages based on page size and total items\n * - Constrains page index to valid bounds\n * - Resets to first page when page size changes\n * - Updates metadata when the dataset changes\n *\n * @typeParam TRow - The type of row data being paginated\n *\n * @param options - Configuration options for the pagination feature\n *\n * @returns A list feature with UI support that provides pagination capabilities\n *\n * @example\n * ```typescript\n * const pagination = paginationFeature({\n *   initialPageIndex: 0,\n *   initialPageSize: 50\n * });\n * ```\n *\n * @example\n * Using with default options:\n * ```typescript\n * const pagination = paginationFeature();\n * ```\n *\n * @public\n */\nexport function paginationFeature<TRow = any>(\n    options: PaginationFeatureOptions = {}\n): ListFeatureWithUI<\n    TRow,\n    any,\n    CoreListState<TRow>,\n    unknown,\n    PaginationApi\n> {\n    const initialPageIndex = options.initialPageIndex ?? 0;\n    const initialPageSize = options.initialPageSize ?? DEFAULT_PAGE_SIZE;\n\n    return {\n        id: FEATURE_ID,\n\n        order: {\n            after: [\"filters\", \"sorting\"],\n        },\n\n        ui: {\n            slots: [\"Pagination\"],\n            requiredHandlers: [\"setPageIndex\", \"setPageSize\"],\n        },\n\n        create(ctx) {\n            const readSlice = (): PaginationSlice => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                return getFeatureSlice<PaginationSlice>(state, FEATURE_ID, () => ({\n                    pageIndex: initialPageIndex,\n                    pageSize: initialPageSize,\n                    totalItems: 0,\n                    totalPages: 0,\n                }));\n            };\n\n            const writeSlice = (slice: PaginationSlice) => {\n                ctx.setState((prev: CoreListState<TRow>) =>\n                    setFeatureSlice(prev, FEATURE_ID, slice)\n                );\n            };\n\n            const api: PaginationApi = {\n                getPagination: () => readSlice(),\n\n                setPageIndex: (pageIndex) => {\n                    const s = readSlice();\n                    writeSlice({\n                        ...s,\n                        pageIndex: Math.max(0, Math.min(pageIndex, s.totalPages - 1)),\n                    });\n                },\n\n                setPageSize: (pageSize) => {\n                    const s = readSlice();\n                    writeSlice({\n                        ...s,\n                        pageSize: Math.max(1, pageSize),\n                        pageIndex: 0, // reset page on size change\n                    });\n                },\n\n                reset: () => {\n                    writeSlice({\n                        pageIndex: initialPageIndex,\n                        pageSize: initialPageSize,\n                        totalItems: 0,\n                        totalPages: 0,\n                    });\n                },\n            };\n\n            return api;\n        },\n\n        derive(rows, ctx) {\n            const state = ctx.stateRef.current as CoreListState<TRow>;\n            const slice = getFeatureSlice<PaginationSlice>(state, FEATURE_ID, () => ({\n                pageIndex: initialPageIndex,\n                pageSize: initialPageSize,\n                totalItems: 0,\n                totalPages: 0,\n            }));\n\n            const totalItems = rows.length;\n            const totalPages = Math.max(1, Math.ceil(totalItems / slice.pageSize));\n\n            const safePageIndex = Math.min(slice.pageIndex, totalPages - 1);\n            const start = safePageIndex * slice.pageSize;\n            const end = start + slice.pageSize;\n\n            // update meta if needed\n            if (\n                slice.totalItems !== totalItems ||\n                slice.totalPages !== totalPages ||\n                slice.pageIndex !== safePageIndex\n            ) {\n                ctx.setState((prev: CoreListState<TRow>) =>\n                    setFeatureSlice(prev, FEATURE_ID, {\n                        ...slice,\n                        pageIndex: safePageIndex,\n                        totalItems,\n                        totalPages,\n                    })\n                );\n            }\n\n            return rows.slice(start, end);\n        },\n    };\n}\n","import {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\n/**\n * Defines the selection mode for a list.\n *\n * @remarks\n * - \"none\": Selection is disabled, no rows can be selected\n * - \"single\": Only one row can be selected at a time\n * - \"multiple\": Multiple rows can be selected simultaneously\n *\n * @public\n */\nexport type SelectionMode = \"none\" | \"single\" | \"multiple\";\n\n/**\n * Internal state slice for the selection feature.\n *\n * @remarks\n * This type represents the portion of the feature state that is managed by\n * the selection feature. It is stored in the global list state under the\n * feature's ID.\n *\n * @typeParam TRowId - The type of row identifier\n *\n * @public\n */\nexport type SelectionSlice<TRowId = any> = {\n    /**\n     * The current selection mode.\n     */\n    mode: SelectionMode;\n\n    /**\n     * The array of currently selected row IDs.\n     */\n    selectedIds: ReadonlyArray<TRowId>;\n};\n\n/**\n * API interface for managing row selection in a list.\n *\n * @remarks\n * This interface provides methods to query and modify the selection state.\n * It is returned by the selection feature and can be used by UI components\n * or other features to interact with the selection.\n *\n * @typeParam TRow - The type of row data\n * @typeParam TRowId - The type of row identifier\n *\n * @public\n */\nexport type SelectionApi<TRow = any, TRowId = any> = {\n    /**\n     * Retrieves the current selection state.\n     *\n     * @returns The current selection slice containing mode and selected IDs\n     */\n    getSelection: () => SelectionSlice<TRowId>;\n\n    /**\n     * Checks if a specific row is currently selected.\n     *\n     * @param rowId - The ID of the row to check\n     * @returns True if the row is selected, false otherwise\n     */\n    isSelected: (rowId: TRowId) => boolean;\n\n    /**\n     * Adds a row to the selection.\n     *\n     * @remarks\n     * In \"single\" mode, this replaces the current selection.\n     * In \"multiple\" mode, this adds to the current selection.\n     * In \"none\" mode, this is a no-op.\n     *\n     * @param rowId - The ID of the row to select\n     */\n    select: (rowId: TRowId) => void;\n\n    /**\n     * Removes a row from the selection.\n     *\n     * @remarks\n     * In \"none\" mode, this is a no-op.\n     *\n     * @param rowId - The ID of the row to deselect\n     */\n    deselect: (rowId: TRowId) => void;\n\n    /**\n     * Toggles the selection state of a row.\n     *\n     * @remarks\n     * If the row is currently selected, it will be deselected.\n     * If the row is not selected, it will be selected.\n     * In \"single\" mode, selecting a new row replaces the current selection.\n     * In \"none\" mode, this is a no-op.\n     *\n     * @param rowId - The ID of the row to toggle\n     */\n    toggle: (rowId: TRowId) => void;\n\n    /**\n     * Clears all selected rows.\n     *\n     * @remarks\n     * This sets the selectedIds array to empty.\n     */\n    clear: () => void;\n\n    /**\n     * Replaces the current selection with a new set of row IDs.\n     *\n     * @remarks\n     * In \"single\" mode, only the first ID is kept.\n     * In \"multiple\" mode, all provided IDs are selected (duplicates are removed).\n     * In \"none\" mode, the selection remains empty.\n     *\n     * @param ids - The array of row IDs to select\n     */\n    setSelected: (ids: ReadonlyArray<TRowId>) => void;\n\n    /**\n     * Selects all currently visible rows in the list.\n     *\n     * @remarks\n     * This operates on the rows array from ctx.stateRef.current.rows.\n     * In \"none\" mode, this is a no-op.\n     * In \"single\" mode, only the first visible row is selected.\n     * In \"multiple\" mode, all visible rows are selected.\n     */\n    selectAllVisible: () => void;\n};\n\n/**\n * Configuration options for the selection feature.\n *\n * @remarks\n * These options define the selection behavior and initial state.\n *\n * @typeParam TRowId - The type of row identifier\n *\n * @public\n */\nexport type SelectionFeatureOptions<TRowId = any> = {\n    /**\n     * The selection mode to use.\n     *\n     * @remarks\n     * If not provided, defaults to \"none\".\n     */\n    mode?: SelectionMode;\n\n    /**\n     * The initial set of selected row IDs.\n     *\n     * @remarks\n     * If not provided, defaults to an empty array.\n     * In \"single\" mode, only the first ID will be used.\n     */\n    initialSelectedIds?: ReadonlyArray<TRowId>;\n};\n\nconst FEATURE_ID = \"selection\";\n\nfunction uniq<T>(arr: ReadonlyArray<T>): T[] {\n    return Array.from(new Set(arr));\n}\n\nfunction removeOne<T>(arr: ReadonlyArray<T>, value: T): T[] {\n    const out: T[] = [];\n    for (const item of arr) {\n        if (item !== value) out.push(item);\n    }\n    return out;\n}\n\n/**\n * Creates a selection feature for a list.\n *\n * @remarks\n * This function creates a list feature that adds row selection capabilities to a list.\n * It provides an API for managing selection state and supports three modes: none, single,\n * and multiple selection. The feature requires ctx.meta.idKey to be defined, which specifies\n * the property name used to extract row IDs.\n *\n * The selection state is automatically managed and persists across list updates.\n * Duplicate IDs are automatically removed, and in single mode, only one row can be\n * selected at a time.\n *\n * @typeParam TRow - The type of row data\n * @typeParam TRowId - The type of row identifier\n *\n * @param options - Configuration options for the selection feature\n *\n * @returns A list feature with UI support that provides selection capabilities\n *\n * @throws Error if ctx.meta.idKey is not provided during feature creation\n *\n * @example\n * ```typescript\n * const selection = selectionFeature({\n *   mode: 'multiple',\n *   initialSelectedIds: [1, 2, 3]\n * });\n * ```\n *\n * @public\n */\nexport function selectionFeature<TRow = any, TRowId = any>(\n    options: SelectionFeatureOptions<TRowId> = {}\n): ListFeatureWithUI<TRow, TRowId, CoreListState<TRow>, unknown, SelectionApi<TRow, TRowId>> {\n    const mode: SelectionMode = options.mode ?? \"none\";\n    const initialSelected = options.initialSelectedIds ?? [];\n\n    return {\n        id: FEATURE_ID,\n\n        create(ctx) {\n            const idKey = ctx.meta?.idKey;\n            if (!idKey) {\n                throw new Error(\"selectionFeature requires ctx.meta.idKey (string) to be provided.\");\n            }\n\n            const readSlice = (): SelectionSlice<TRowId> => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                return getFeatureSlice<SelectionSlice<TRowId>>(state, FEATURE_ID, () => {\n                    const ids = mode === \"none\" ? [] : uniq(initialSelected);\n                    return {\n                        mode,\n                        selectedIds: mode === \"single\" ? ids.slice(0, 1) : ids,\n                    };\n                });\n            };\n\n            const writeSlice = (next: SelectionSlice<TRowId>) => {\n                ctx.setState((prev: CoreListState<TRow>) => setFeatureSlice(prev, FEATURE_ID, next));\n            };\n\n            const coerce = (ids: ReadonlyArray<TRowId>): TRowId[] => {\n                if (mode === \"none\") return [];\n                const unique = uniq(ids);\n                return mode === \"single\" ? unique.slice(0, 1) : unique;\n            };\n\n            const api: SelectionApi<TRow, TRowId> = {\n                getSelection: () => readSlice(),\n\n                isSelected: (rowId) => {\n                    const {selectedIds} = readSlice();\n                    return selectedIds.includes(rowId);\n                },\n\n                select: (rowId) => {\n                    if (mode === \"none\") return;\n                    const s = readSlice();\n                    const next = coerce([...s.selectedIds, rowId]);\n                    writeSlice({...s, selectedIds: next});\n                },\n\n                deselect: (rowId) => {\n                    if (mode === \"none\") return;\n                    const s = readSlice();\n                    const next = removeOne(s.selectedIds, rowId);\n                    writeSlice({...s, selectedIds: next});\n                },\n\n                toggle: (rowId) => {\n                    if (mode === \"none\") return;\n                    const s = readSlice();\n                    const isOn = s.selectedIds.includes(rowId);\n                    const next = isOn ? removeOne(s.selectedIds, rowId) : coerce([...s.selectedIds, rowId]);\n                    writeSlice({...s, selectedIds: next});\n                },\n\n                clear: () => {\n                    const s = readSlice();\n                    if (s.selectedIds.length === 0) return;\n                    writeSlice({...s, selectedIds: []});\n                },\n\n                setSelected: (ids) => {\n                    const s = readSlice();\n                    const next = coerce(ids);\n                    writeSlice({...s, selectedIds: next});\n                },\n\n                selectAllVisible: () => {\n                    if (mode === \"none\") return;\n\n                    const s = readSlice();\n                    const state = ctx.stateRef.current as CoreListState<TRow>;\n                    const rows = state.rows ?? [];\n\n                    const ids = rows\n                        .map((r) => (r as any)[idKey] as TRowId)\n                        .filter((v) => v != null);\n\n                    const next = mode === \"single\" ? ids.slice(0, 1) : uniq(ids);\n                    writeSlice({...s, selectedIds: next});\n                },\n            };\n\n            return api;\n        },\n    };\n}\n","import {ListFeatureContext} from \"../../core/context/listFeatureContext\";\nimport {CoreListState} from \"../../core/store/coreState\";\nimport {ListFeatureWithUI} from \"../../core/contracts/listFeatureWithUI\";\nimport {getFeatureSlice, setFeatureSlice} from \"../../core/store/featureState\";\n\n/**\n * Defines the direction of sorting operations.\n *\n * @remarks\n * This type specifies whether sorting should be in ascending or descending order.\n *\n * @public\n */\nexport type SortDirection = \"asc\" | \"desc\";\n\n/**\n * Represents the sort descriptor for a list.\n *\n * @remarks\n * This type is intentionally kept simple and serializable to allow maximum flexibility.\n * The fieldId is a generic string to match schema field identifiers. A null value\n * indicates no sorting is applied.\n *\n * @public\n */\nexport type SortValue = {\n    /**\n     * The identifier of the field to sort by.\n     *\n     * @remarks\n     * This should match the field identifiers in your data schema.\n     */\n    fieldId: string;\n\n    /**\n     * The direction of the sort operation.\n     *\n     * @remarks\n     * If not provided, defaults to \"asc\" (ascending).\n     */\n    direction?: SortDirection;\n} | null;\n\n/**\n * Internal state slice for the sorting feature.\n *\n * @remarks\n * This type represents the portion of the feature state that is managed by\n * the sorting feature. It is stored in the global list state under the\n * feature's ID.\n *\n * @internal\n */\ntype SortingSlice = {\n    /**\n     * The current sort value.\n     */\n    value: SortValue;\n};\n\n/**\n * API interface for managing sorting in a list.\n *\n * @remarks\n * This interface provides methods to get, set, and clear sort values.\n * It is returned by the sorting feature and can be used by UI components\n * or other features to interact with the sorting state.\n *\n * @public\n */\nexport type SortingApi = {\n    /**\n     * Retrieves the current sort value.\n     *\n     * @returns The current sort value\n     */\n    getSort: () => SortValue;\n\n    /**\n     * Sets a new sort value.\n     *\n     * @remarks\n     * Can accept either a direct value or a function that receives the previous\n     * sort and returns the new sort. This allows for both direct updates\n     * and updates based on the current state.\n     *\n     * @param next - The new sort value or a function to compute it from the previous value\n     */\n    setSort: (next: SortValue | ((prev: SortValue) => SortValue)) => void;\n\n    /**\n     * Resets the sort to its initial value.\n     *\n     * @remarks\n     * This will set the sort back to the value specified in the `initial` option,\n     * or to null if no initial value was provided.\n     */\n    clearSort: () => void;\n};\n\n/**\n * Configuration options for the sorting feature.\n *\n * @remarks\n * These options define how the sorting feature behaves. The feature supports two modes:\n * - \"apply\": Provides full control over the sorting implementation by accepting a function that returns sorted rows\n * - \"compare\": Uses a comparator function that the library uses with Array.sort()\n *\n * The library remains agnostic to the actual sorting implementation.\n *\n * @typeParam TRow - The type of row data being sorted\n *\n * @public\n */\nexport type SortingFeatureOptions<TRow = any> =\n    | {\n    /**\n     * Specifies that sorting should use the apply strategy.\n     */\n    mode: \"apply\";\n\n    /**\n     * The sorting strategy function that applies sorting to rows.\n     *\n     * @remarks\n     * This function receives the rows and sort value, and returns the sorted rows.\n     * You have full control over the sorting implementation.\n     *\n     * @param rows - The readonly array of rows to be sorted\n     * @param sort - The current sort value to apply\n     * @param ctx - The list feature context providing access to state and utilities\n     *\n     * @returns A readonly array of sorted rows\n     */\n    apply: (\n        rows: readonly TRow[],\n        sort: SortValue,\n        ctx: ListFeatureContext<TRow, any, CoreListState<TRow>, unknown>\n    ) => readonly TRow[];\n\n    /**\n     * The initial sort value to use when the feature is first created.\n     *\n     * @remarks\n     * If not provided, defaults to null (no sorting).\n     */\n    initial?: SortValue;\n}\n    | {\n    /**\n     * Specifies that sorting should use the compare strategy.\n     */\n    mode: \"compare\";\n\n    /**\n     * The comparator function used to compare two rows.\n     *\n     * @remarks\n     * This function follows the standard JavaScript comparator pattern:\n     * - Return negative number if a should come before b\n     * - Return positive number if a should come after b\n     * - Return 0 if they are equal\n     *\n     * The library handles direction reversal for descending sorts automatically.\n     *\n     * @param a - The first row to compare\n     * @param b - The second row to compare\n     * @param sort - The current sort value (guaranteed to be non-null)\n     * @param ctx - The list feature context providing access to state and utilities\n     *\n     * @returns A number indicating the sort order\n     */\n    compare: (\n        a: TRow,\n        b: TRow,\n        sort: NonNullable<SortValue>,\n        ctx: ListFeatureContext<TRow, any, CoreListState<TRow>, unknown>\n    ) => number;\n\n    /**\n     * The initial sort value to use when the feature is first created.\n     *\n     * @remarks\n     * If not provided, defaults to null (no sorting).\n     */\n    initial?: SortValue;\n};\n\n\nconst FEATURE_ID = \"sorting\";\n\n/**\n * Normalizes a sort value by ensuring it has a direction.\n *\n * @remarks\n * This internal function ensures that all sort values have an explicit direction,\n * defaulting to \"asc\" if not specified. Null values are preserved.\n *\n * @param value - The sort value to normalize\n *\n * @returns The normalized sort value with explicit direction, or null\n *\n * @internal\n */\nfunction normalizeSort(value: SortValue): SortValue {\n    if (!value) return null;\n    const direction: SortDirection = value.direction ?? \"asc\";\n    return {fieldId: value.fieldId, direction};\n}\n\n/**\n * Creates a sorting feature for a list.\n *\n * @remarks\n * This function creates a list feature that adds sorting capabilities to a list.\n * It provides an API for managing sort state and automatically applies sorting\n * during the derive phase. The feature includes UI slots for sort bars and\n * requires setSort handler to be implemented.\n *\n * The sorting logic is completely customizable through either the `apply` or `compare`\n * function, allowing you to implement any sorting strategy that fits your needs.\n *\n * The feature is configured to execute after filtering (if filtering is registered),\n * ensuring the correct order of operations in the data processing pipeline.\n *\n * @typeParam TRow - The type of row data being sorted\n *\n * @param options - Configuration options for the sorting feature\n *\n * @returns A list feature with UI support that provides sorting capabilities\n *\n * @throws Error if neither `apply` nor `compare` function is provided in options\n *\n * @example\n * Using apply mode:\n * ```typescript\n * const sorting = sortingFeature({\n *   mode: \"apply\",\n *   apply: (rows, sort) => {\n *     if (!sort) return rows;\n *     return [...rows].sort((a, b) => {\n *       const aVal = a[sort.fieldId];\n *       const bVal = b[sort.fieldId];\n *       const comparison = aVal > bVal ? 1 : aVal < bVal ? -1 : 0;\n *       return sort.direction === \"desc\" ? -comparison : comparison;\n *     });\n *   },\n *   initial: { fieldId: \"name\", direction: \"asc\" }\n * });\n * ```\n *\n * @example\n * Using compare mode:\n * ```typescript\n * const sorting = sortingFeature({\n *   mode: \"compare\",\n *   compare: (a, b, sort) => {\n *     const aVal = a[sort.fieldId];\n *     const bVal = b[sort.fieldId];\n *     return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;\n *   },\n *   initial: { fieldId: \"date\", direction: \"desc\" }\n * });\n * ```\n *\n * @public\n */\nexport function sortingFeature<TRow = any>(\n    options: SortingFeatureOptions<TRow>\n): ListFeatureWithUI<TRow, any, CoreListState<TRow>, unknown, SortingApi> {\n    if (!options) {\n        throw new Error(\"sortingFeature requires options.\");\n    }\n    const hasApply = (options as any).apply != null;\n    const hasCompare = (options as any).compare != null;\n\n    if (!hasApply && !hasCompare) {\n        throw new Error(\"sortingFeature requires either an 'apply' or 'compare' function.\");\n    }\n\n    return {\n        id: FEATURE_ID,\n\n        order: {\n            after: [\"filters\"],\n        },\n\n        ui: {\n            slots: [\"SortBar\"],\n            requiredHandlers: [\"setSort\"],\n        },\n\n        create(ctx) {\n            const readSlice = (): SortingSlice => {\n                const state = ctx.stateRef.current as CoreListState<TRow>;\n                return getFeatureSlice<SortingSlice>(state, FEATURE_ID, () => ({\n                    value: normalizeSort((options as any).initial ?? null),\n                }));\n            };\n\n            const writeSlice = (slice: SortingSlice) => {\n                ctx.setState((prev: CoreListState<TRow>) => setFeatureSlice(prev, FEATURE_ID, slice));\n            };\n\n            const api: SortingApi = {\n                getSort: () => readSlice().value,\n\n                setSort: (next) => {\n                    const prevValue = readSlice().value;\n                    const resolved = typeof next === \"function\"\n                        ? (next as (p: SortValue) => SortValue)(prevValue)\n                        : next;\n\n                    writeSlice({value: normalizeSort(resolved)});\n                },\n\n                clearSort: () => {\n                    writeSlice({value: normalizeSort((options as any).initial ?? null)});\n                },\n            };\n\n            return api;\n        },\n\n        derive(rows, ctx) {\n            const state = ctx.stateRef.current as CoreListState<TRow>;\n            const slice = getFeatureSlice<SortingSlice>(state, FEATURE_ID, () => ({\n                value: normalizeSort((options as any).initial ?? null),\n            }));\n\n            const sort = slice.value;\n            if (!sort) return rows;\n\n            if (!sort) return rows;\n\n            if (options.mode === \"apply\") {\n                return options.apply(rows, sort, ctx);\n            }\n\n            const out = [...rows];\n            out.sort((a, b) => {\n                const base = options.compare(a, b, sort, ctx);\n                return sort.direction === \"desc\" ? -base : base;\n            });\n            return out;\n        },\n    };\n}\n"]}